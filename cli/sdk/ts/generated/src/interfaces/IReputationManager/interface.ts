// Auto-generated interface wrapper for IReputationManager
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Hex, Address } from 'viem';
import type { ReputationRecord } from '../../types';
import { IREPUTATIONMANAGER_ABI } from './abi';

export interface IReputationManagerConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class IReputationManager {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: IReputationManagerConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * getAgentRatingCount
   * view
   */
  async getAgentRatingCount(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'getAgentRatingCount',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAgentRatingData
   * view
   */
  async getAgentRatingData(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'getAgentRatingData',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAgentReputationScore
   * view
   */
  async getAgentReputationScore(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'getAgentReputationScore',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAgentReputationScoreWithTags
   * view
   */
  async getAgentReputationScoreWithTags(agentId_: Hash, tags_: string[]): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'getAgentReputationScoreWithTags',
      args: [agentId_, tags_] as any,
    }) as bigint;
  }

  /**
   * getBidRating
   * view
   */
  async getBidRating(bidId_: Hash): Promise<ReputationRecord> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'getBidRating',
      args: [bidId_] as any,
    }) as ReputationRecord;
  }

  /**
   * isBidRated
   * view
   */
  async isBidRated(bidId_: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'isBidRated',
      args: [bidId_] as any,
    }) as boolean;
  }

  /**
   * resolveWithProof
   * view
   */
  async resolveWithProof(proof: Hex, originalCalldata: Hex): Promise<Hex> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'resolveWithProof',
      args: [proof, originalCalldata] as any,
    }) as Hex;
  }

  /**
   * setReputationProvider
   * nonpayable
   */
  async setReputationProvider(agentId_: Hash, provider_: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'setReputationProvider',
      args: [agentId_, provider_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * submitDetailedRating
   * nonpayable
   */
  async submitDetailedRating(bidId_: Hash, agentId_: Hash, score: number, comment: string, tags: number[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'submitDetailedRating',
      args: [bidId_, agentId_, score, comment, tags] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * submitRating
   * nonpayable
   */
  async submitRating(bidId_: Hash, agentId_: Hash, score: number, comment: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      functionName: 'submitRating',
      args: [bidId_, agentId_, score, comment] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get AgentRatingCountUpdated event logs
   */
  async getAgentRatingCountUpdatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IREPUTATIONMANAGER_ABI.find(e => e.type === 'event' && e.name === 'AgentRatingCountUpdated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get RatingSubmitted event logs
   */
  async getRatingSubmittedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IREPUTATIONMANAGER_ABI.find(e => e.type === 'event' && e.name === 'RatingSubmitted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get ReputationProviderSet event logs
   */
  async getReputationProviderSetLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IREPUTATIONMANAGER_ABI.find(e => e.type === 'event' && e.name === 'ReputationProviderSet'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Watch AgentRatingCountUpdated events
   */
  watchAgentRatingCountUpdated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      eventName: 'AgentRatingCountUpdated',
      onLogs,
    });
  }

  /**
   * Watch RatingSubmitted events
   */
  watchRatingSubmitted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      eventName: 'RatingSubmitted',
      onLogs,
    });
  }

  /**
   * Watch ReputationProviderSet events
   */
  watchReputationProviderSet(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IREPUTATIONMANAGER_ABI,
      eventName: 'ReputationProviderSet',
      onLogs,
    });
  }
}
