// Auto-generated interface wrapper for IToken
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address } from 'viem';

import { ITOKEN_ABI } from './abi';

export interface ITokenConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class IToken {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: ITokenConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * DOMAIN_SEPARATOR
   * view
   */
  async DOMAIN_SEPARATOR(): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'DOMAIN_SEPARATOR',
      args: [],
    }) as Hash;
  }

  /**
   * allowance
   * view
   */
  async allowance(owner: Address, spender: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'allowance',
      args: [owner, spender] as any,
    }) as bigint;
  }

  /**
   * approve
   * nonpayable
   */
  async approve(spender: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'approve',
      args: [spender, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * balanceOf
   * view
   */
  async balanceOf(account: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'balanceOf',
      args: [account] as any,
    }) as bigint;
  }

  /**
   * nonces
   * view
   */
  async nonces(owner: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'nonces',
      args: [owner] as any,
    }) as bigint;
  }

  /**
   * permit
   * nonpayable
   */
  async permit(owner: Address, spender: Address, value: bigint, deadline: bigint, v: number, r: Hash, s: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'permit',
      args: [owner, spender, value, deadline, v, r, s] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * totalSupply
   * view
   */
  async totalSupply(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'totalSupply',
      args: [],
    }) as bigint;
  }

  /**
   * transfer
   * nonpayable
   */
  async transfer(to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'transfer',
      args: [to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * transferFrom
   * nonpayable
   */
  async transferFrom(from: Address, to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKEN_ABI,
      functionName: 'transferFrom',
      args: [from, to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get Approval event logs
   */
  async getApprovalLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    owner?: Address, spender?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKEN_ABI.find(e => e.type === 'event' && e.name === 'Approval'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { owner: options?.owner, spender: options?.spender }
    }) as any[];
  }

  /**
   * Get Transfer event logs
   */
  async getTransferLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    from?: Address, to?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKEN_ABI.find(e => e.type === 'event' && e.name === 'Transfer'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { from: options?.from, to: options?.to }
    }) as any[];
  }

  /**
   * Watch Approval events
   */
  watchApproval(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKEN_ABI,
      eventName: 'Approval',
      onLogs,
    });
  }

  /**
   * Watch Transfer events
   */
  watchTransfer(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKEN_ABI,
      eventName: 'Transfer',
      onLogs,
    });
  }
}
