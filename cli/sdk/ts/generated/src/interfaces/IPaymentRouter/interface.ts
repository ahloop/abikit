// Auto-generated interface wrapper for IPaymentRouter
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address, Hex } from 'viem';

import { IPAYMENTROUTER_ABI } from './abi';

export interface IPaymentRouterConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class IPaymentRouter {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: IPaymentRouterConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * getAmountInMax
   * view
   */
  async getAmountInMax(amountOut: bigint, path: Hex): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'getAmountInMax',
      args: [amountOut, path] as any,
    }) as bigint;
  }

  /**
   * getAmountOutMin
   * view
   */
  async getAmountOutMin(amountIn: bigint, path: Hex): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'getAmountOutMin',
      args: [amountIn, path] as any,
    }) as bigint;
  }

  /**
   * isTokenSupported
   * view
   */
  async isTokenSupported(token: Address): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'isTokenSupported',
      args: [token] as any,
    }) as boolean;
  }

  /**
   * network
   * view
   */
  async network(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'network',
      args: [],
    }) as Address;
  }

  /**
   * payReputationFee
   * nonpayable
   */
  async payReputationFee(provider: Address, amount: bigint, bidId: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'payReputationFee',
      args: [provider, amount, bidId] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setMaxSwapAmount
   * nonpayable
   */
  async setMaxSwapAmount(_maxSwapAmount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'setMaxSwapAmount',
      args: [_maxSwapAmount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setMinSwapAmount
   * nonpayable
   */
  async setMinSwapAmount(_minSwapAmount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'setMinSwapAmount',
      args: [_minSwapAmount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setNetwork
   * nonpayable
   */
  async setNetwork(_network: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'setNetwork',
      args: [_network] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setSlippageTolerance
   * nonpayable
   */
  async setSlippageTolerance(_slippageTolerance: number): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'setSlippageTolerance',
      args: [_slippageTolerance] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setTokenVault
   * nonpayable
   */
  async setTokenVault(_tokenVault: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'setTokenVault',
      args: [_tokenVault] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * settlePayment
   * nonpayable
   */
  async settlePayment(bidId: Hash, recipient: Address, amount: bigint, refundPercent: number, reputationProvider: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'settlePayment',
      args: [bidId, recipient, amount, refundPercent, reputationProvider] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * swapExactTokensForTokens
   * nonpayable
   */
  async swapExactTokensForTokens(tokenIn: Address, amountIn: bigint, amountOutMinimum: bigint, path: Hex, deadline: bigint, recipient: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'swapExactTokensForTokens',
      args: [tokenIn, amountIn, amountOutMinimum, path, deadline, recipient] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * swapExactTokensForTokensWithPermit
   * nonpayable
   */
  async swapExactTokensForTokensWithPermit(tokenIn: Address, amountIn: bigint, amountOutMinimum: bigint, path: Hex, deadline: bigint, recipient: Address, permitDeadline: bigint, v: number, r: Hash, s: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'swapExactTokensForTokensWithPermit',
      args: [tokenIn, amountIn, amountOutMinimum, path, deadline, recipient, permitDeadline, v, r, s] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * swapRouter
   * view
   */
  async swapRouter(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'swapRouter',
      args: [],
    }) as Address;
  }

  /**
   * swapTokensForExactTokens
   * nonpayable
   */
  async swapTokensForExactTokens(tokenIn: Address, amountOut: bigint, amountInMaximum: bigint, path: Hex, deadline: bigint, recipient: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'swapTokensForExactTokens',
      args: [tokenIn, amountOut, amountInMaximum, path, deadline, recipient] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * tokenVault
   * view
   */
  async tokenVault(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'tokenVault',
      args: [],
    }) as Address;
  }

  /**
   * usdc
   * view
   */
  async usdc(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      functionName: 'usdc',
      args: [],
    }) as Address;
  }

  /**
   * Get PaymentSettled event logs
   */
  async getPaymentSettledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, recipient?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IPAYMENTROUTER_ABI.find(e => e.type === 'event' && e.name === 'PaymentSettled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, recipient: options?.recipient }
    }) as any[];
  }

  /**
   * Get ReputationFeePaid event logs
   */
  async getReputationFeePaidLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    provider?: Address, bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IPAYMENTROUTER_ABI.find(e => e.type === 'event' && e.name === 'ReputationFeePaid'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { provider: options?.provider, bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get SwapExecuted event logs
   */
  async getSwapExecutedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    tokenIn?: Address, tokenOut?: Address, recipient?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IPAYMENTROUTER_ABI.find(e => e.type === 'event' && e.name === 'SwapExecuted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { tokenIn: options?.tokenIn, tokenOut: options?.tokenOut, recipient: options?.recipient }
    }) as any[];
  }

  /**
   * Watch PaymentSettled events
   */
  watchPaymentSettled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      eventName: 'PaymentSettled',
      onLogs,
    });
  }

  /**
   * Watch ReputationFeePaid events
   */
  watchReputationFeePaid(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      eventName: 'ReputationFeePaid',
      onLogs,
    });
  }

  /**
   * Watch SwapExecuted events
   */
  watchSwapExecuted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IPAYMENTROUTER_ABI,
      eventName: 'SwapExecuted',
      onLogs,
    });
  }
}
