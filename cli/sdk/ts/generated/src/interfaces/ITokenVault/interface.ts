// Auto-generated interface wrapper for ITokenVault
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address } from 'viem';

import { ITOKENVAULT_ABI } from './abi';

export interface ITokenVaultConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class ITokenVault {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: ITokenVaultConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * allowance
   * view
   */
  async allowance(owner: Address, spender: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'allowance',
      args: [owner, spender] as any,
    }) as bigint;
  }

  /**
   * applyNegativeFee
   * nonpayable
   */
  async applyNegativeFee(bidId: Hash, amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'applyNegativeFee',
      args: [bidId, amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * approve
   * nonpayable
   */
  async approve(spender: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'approve',
      args: [spender, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * asset
   * view
   */
  async asset(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'asset',
      args: [],
    }) as Address;
  }

  /**
   * balanceOf
   * view
   */
  async balanceOf(account: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'balanceOf',
      args: [account] as any,
    }) as bigint;
  }

  /**
   * collectFees
   * nonpayable
   */
  async collectFees(from: Address, amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'collectFees',
      args: [from, amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * collectFeesWithMicroFee
   * nonpayable
   */
  async collectFeesWithMicroFee(from: Address, amount: bigint, reputationProvider: Address, bidId: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'collectFeesWithMicroFee',
      args: [from, amount, reputationProvider, bidId] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * convertToAssets
   * view
   */
  async convertToAssets(shares: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'convertToAssets',
      args: [shares] as any,
    }) as bigint;
  }

  /**
   * convertToShares
   * view
   */
  async convertToShares(assets: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'convertToShares',
      args: [assets] as any,
    }) as bigint;
  }

  /**
   * decimals
   * view
   */
  async decimals(): Promise<number> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'decimals',
      args: [],
    }) as number;
  }

  /**
   * deposit
   * nonpayable
   */
  async deposit(assets: bigint, receiver: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'deposit',
      args: [assets, receiver] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * getFeeAmount
   * view
   */
  async getFeeAmount(amount: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getFeeAmount',
      args: [amount] as any,
    }) as bigint;
  }

  /**
   * getMaxFeeRate
   * pure
   */
  async getMaxFeeRate(): Promise<number> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getMaxFeeRate',
      args: [],
    }) as number;
  }

  /**
   * getMaxNegativeFeeRate
   * pure
   */
  async getMaxNegativeFeeRate(): Promise<unknown> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getMaxNegativeFeeRate',
      args: [],
    }) as unknown;
  }

  /**
   * getNegativeFeeAmount
   * view
   */
  async getNegativeFeeAmount(amount: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getNegativeFeeAmount',
      args: [amount] as any,
    }) as bigint;
  }

  /**
   * getReputationProviderFeeBalance
   * view
   */
  async getReputationProviderFeeBalance(provider: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getReputationProviderFeeBalance',
      args: [provider] as any,
    }) as bigint;
  }

  /**
   * getSponsoredBidBalance
   * view
   */
  async getSponsoredBidBalance(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getSponsoredBidBalance',
      args: [],
    }) as bigint;
  }

  /**
   * getSponsoredBidSubsidy
   * view
   */
  async getSponsoredBidSubsidy(bidId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getSponsoredBidSubsidy',
      args: [bidId] as any,
    }) as bigint;
  }

  /**
   * getTreasuryBalance
   * view
   */
  async getTreasuryBalance(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'getTreasuryBalance',
      args: [],
    }) as bigint;
  }

  /**
   * initializeTreasury
   * nonpayable
   */
  async initializeTreasury(_token: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'initializeTreasury',
      args: [_token] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * isInitialized
   * view
   */
  async isInitialized(): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'isInitialized',
      args: [],
    }) as boolean;
  }

  /**
   * maxDeposit
   * view
   */
  async maxDeposit(receiver: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'maxDeposit',
      args: [receiver] as any,
    }) as bigint;
  }

  /**
   * maxMint
   * view
   */
  async maxMint(receiver: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'maxMint',
      args: [receiver] as any,
    }) as bigint;
  }

  /**
   * maxRedeem
   * view
   */
  async maxRedeem(owner: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'maxRedeem',
      args: [owner] as any,
    }) as bigint;
  }

  /**
   * maxWithdraw
   * view
   */
  async maxWithdraw(owner: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'maxWithdraw',
      args: [owner] as any,
    }) as bigint;
  }

  /**
   * mint
   * nonpayable
   */
  async mint(shares: bigint, receiver: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'mint',
      args: [shares, receiver] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * name
   * view
   */
  async name(): Promise<string> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'name',
      args: [],
    }) as string;
  }

  /**
   * previewDeposit
   * view
   */
  async previewDeposit(assets: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'previewDeposit',
      args: [assets] as any,
    }) as bigint;
  }

  /**
   * previewMint
   * view
   */
  async previewMint(shares: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'previewMint',
      args: [shares] as any,
    }) as bigint;
  }

  /**
   * previewRedeem
   * view
   */
  async previewRedeem(shares: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'previewRedeem',
      args: [shares] as any,
    }) as bigint;
  }

  /**
   * previewWithdraw
   * view
   */
  async previewWithdraw(assets: bigint): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'previewWithdraw',
      args: [assets] as any,
    }) as bigint;
  }

  /**
   * redeem
   * nonpayable
   */
  async redeem(shares: bigint, receiver: Address, owner: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'redeem',
      args: [shares, receiver, owner] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setFeeRate
   * nonpayable
   */
  async setFeeRate(_feeRate: number): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'setFeeRate',
      args: [_feeRate] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setMicroFeeAmount
   * nonpayable
   */
  async setMicroFeeAmount(_microFeeAmount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'setMicroFeeAmount',
      args: [_microFeeAmount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setNegativeFeeRate
   * nonpayable
   */
  async setNegativeFeeRate(_negativeFeeRate: unknown): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'setNegativeFeeRate',
      args: [_negativeFeeRate] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * sponsorBid
   * nonpayable
   */
  async sponsorBid(bidId: Hash, subsidyAmount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'sponsorBid',
      args: [bidId, subsidyAmount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * symbol
   * view
   */
  async symbol(): Promise<string> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'symbol',
      args: [],
    }) as string;
  }

  /**
   * totalAssets
   * view
   */
  async totalAssets(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'totalAssets',
      args: [],
    }) as bigint;
  }

  /**
   * totalSupply
   * view
   */
  async totalSupply(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'totalSupply',
      args: [],
    }) as bigint;
  }

  /**
   * transfer
   * nonpayable
   */
  async transfer(to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'transfer',
      args: [to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * transferFrom
   * nonpayable
   */
  async transferFrom(from: Address, to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'transferFrom',
      args: [from, to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * withdraw
   * nonpayable
   */
  async withdraw(assets: bigint, receiver: Address, owner: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'withdraw',
      args: [assets, receiver, owner] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * withdrawReputationProviderFees
   * nonpayable
   */
  async withdrawReputationProviderFees(amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'withdrawReputationProviderFees',
      args: [amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * withdrawTreasury
   * nonpayable
   */
  async withdrawTreasury(to: Address, amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ITOKENVAULT_ABI,
      functionName: 'withdrawTreasury',
      args: [to, amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get Approval event logs
   */
  async getApprovalLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    owner?: Address, spender?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'Approval'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { owner: options?.owner, spender: options?.spender }
    }) as any[];
  }

  /**
   * Get BidSponsored event logs
   */
  async getBidSponsoredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'BidSponsored'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get Deposit event logs
   */
  async getDepositLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    sender?: Address, owner?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'Deposit'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { sender: options?.sender, owner: options?.owner }
    }) as any[];
  }

  /**
   * Get FeesCollected event logs
   */
  async getFeesCollectedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    from?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'FeesCollected'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { from: options?.from }
    }) as any[];
  }

  /**
   * Get MicroFeePaid event logs
   */
  async getMicroFeePaidLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    provider?: Address, bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'MicroFeePaid'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { provider: options?.provider, bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get NegativeFeeApplied event logs
   */
  async getNegativeFeeAppliedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'NegativeFeeApplied'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get ReputationProviderFeeWithdrawn event logs
   */
  async getReputationProviderFeeWithdrawnLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    provider?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'ReputationProviderFeeWithdrawn'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { provider: options?.provider }
    }) as any[];
  }

  /**
   * Get Transfer event logs
   */
  async getTransferLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    from?: Address, to?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'Transfer'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { from: options?.from, to: options?.to }
    }) as any[];
  }

  /**
   * Get TreasuryInitialized event logs
   */
  async getTreasuryInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    token?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'TreasuryInitialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { token: options?.token }
    }) as any[];
  }

  /**
   * Get TreasuryWithdrawn event logs
   */
  async getTreasuryWithdrawnLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    to?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'TreasuryWithdrawn'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { to: options?.to }
    }) as any[];
  }

  /**
   * Get Withdraw event logs
   */
  async getWithdrawLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    sender?: Address, receiver?: Address, owner?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ITOKENVAULT_ABI.find(e => e.type === 'event' && e.name === 'Withdraw'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { sender: options?.sender, receiver: options?.receiver, owner: options?.owner }
    }) as any[];
  }

  /**
   * Watch Approval events
   */
  watchApproval(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'Approval',
      onLogs,
    });
  }

  /**
   * Watch BidSponsored events
   */
  watchBidSponsored(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'BidSponsored',
      onLogs,
    });
  }

  /**
   * Watch Deposit events
   */
  watchDeposit(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'Deposit',
      onLogs,
    });
  }

  /**
   * Watch FeesCollected events
   */
  watchFeesCollected(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'FeesCollected',
      onLogs,
    });
  }

  /**
   * Watch MicroFeePaid events
   */
  watchMicroFeePaid(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'MicroFeePaid',
      onLogs,
    });
  }

  /**
   * Watch NegativeFeeApplied events
   */
  watchNegativeFeeApplied(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'NegativeFeeApplied',
      onLogs,
    });
  }

  /**
   * Watch ReputationProviderFeeWithdrawn events
   */
  watchReputationProviderFeeWithdrawn(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'ReputationProviderFeeWithdrawn',
      onLogs,
    });
  }

  /**
   * Watch Transfer events
   */
  watchTransfer(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'Transfer',
      onLogs,
    });
  }

  /**
   * Watch TreasuryInitialized events
   */
  watchTreasuryInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'TreasuryInitialized',
      onLogs,
    });
  }

  /**
   * Watch TreasuryWithdrawn events
   */
  watchTreasuryWithdrawn(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'TreasuryWithdrawn',
      onLogs,
    });
  }

  /**
   * Watch Withdraw events
   */
  watchWithdraw(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ITOKENVAULT_ABI,
      eventName: 'Withdraw',
      onLogs,
    });
  }
}
