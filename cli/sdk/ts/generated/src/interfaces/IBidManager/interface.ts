// Auto-generated interface wrapper for IBidManager
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address, Hex } from 'viem';
import type { Bid, SettlementDetails, BidAuthorization, ReputationProvider, ReputationRecord } from '../../types';
import { IBIDMANAGER_ABI } from './abi';

export interface IBidManagerConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class IBidManager {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: IBidManagerConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * acceptBid
   * nonpayable
   */
  async acceptBid(bidId: Hash, signature: Hex, resultHash: Hash, allowedAgentsProof: Hash[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'acceptBid',
      args: [bidId, signature, resultHash, allowedAgentsProof] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * auditBid
   * nonpayable
   */
  async auditBid(bidId: Hash, valid: boolean, refundPercent: number): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'auditBid',
      args: [bidId, valid, refundPercent] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * bidExists
   * view
   */
  async bidExists(bidId: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'bidExists',
      args: [bidId] as any,
    }) as boolean;
  }

  /**
   * cancelBid
   * nonpayable
   */
  async cancelBid(bidId: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'cancelBid',
      args: [bidId] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * checkBidExpirations
   * nonpayable
   */
  async checkBidExpirations(bidIds: Hash[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'checkBidExpirations',
      args: [bidIds] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * completeBid
   * nonpayable
   */
  async completeBid(bidId: Hash, responseHash: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'completeBid',
      args: [bidId, responseHash] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * disputeSettlement
   * nonpayable
   */
  async disputeSettlement(bidId: Hash, reason: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'disputeSettlement',
      args: [bidId, reason] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * finalizeSettlement
   * nonpayable
   */
  async finalizeSettlement(bidId: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'finalizeSettlement',
      args: [bidId] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * getAgentTotalSettlements
   * view
   */
  async getAgentTotalSettlements(agentId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getAgentTotalSettlements',
      args: [agentId] as any,
    }) as bigint;
  }

  /**
   * getBid
   * view
   */
  async getBid(bidId: Hash): Promise<Bid> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getBid',
      args: [bidId] as any,
    }) as Bid;
  }

  /**
   * getBidExpirationTime
   * view
   */
  async getBidExpirationTime(bidId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getBidExpirationTime',
      args: [bidId] as any,
    }) as bigint;
  }

  /**
   * getBidState
   * view
   */
  async getBidState(bidId: Hash): Promise<number> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getBidState',
      args: [bidId] as any,
    }) as number;
  }

  /**
   * getDisputeDetails
   * view
   */
  async getDisputeDetails(bidId: Hash): Promise<[bigint, boolean, number, boolean, Address]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getDisputeDetails',
      args: [bidId] as any,
    }) as [bigint, boolean, number, boolean, Address];
  }

  /**
   * getDisputeWindow
   * view
   */
  async getDisputeWindow(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getDisputeWindow',
      args: [],
    }) as bigint;
  }

  /**
   * getMinTrustScore
   * view
   */
  async getMinTrustScore(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getMinTrustScore',
      args: [],
    }) as bigint;
  }

  /**
   * getOffererActiveBidAt
   * view
   */
  async getOffererActiveBidAt(offererId: Hash, index: bigint): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getOffererActiveBidAt',
      args: [offererId, index] as any,
    }) as Hash;
  }

  /**
   * getOffererActiveBidsCount
   * view
   */
  async getOffererActiveBidsCount(offererId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getOffererActiveBidsCount',
      args: [offererId] as any,
    }) as bigint;
  }

  /**
   * getOffererTotalSettlements
   * view
   */
  async getOffererTotalSettlements(offererId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getOffererTotalSettlements',
      args: [offererId] as any,
    }) as bigint;
  }

  /**
   * getPendingBidAt
   * view
   */
  async getPendingBidAt(agentId: Hash, index: bigint): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getPendingBidAt',
      args: [agentId, index] as any,
    }) as Hash;
  }

  /**
   * getPendingBidsCount
   * view
   */
  async getPendingBidsCount(agentId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getPendingBidsCount',
      args: [agentId] as any,
    }) as bigint;
  }

  /**
   * getRatingDetails
   * view
   */
  async getRatingDetails(bidId: Hash): Promise<[boolean, boolean, boolean, boolean]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getRatingDetails',
      args: [bidId] as any,
    }) as [boolean, boolean, boolean, boolean];
  }

  /**
   * getScore
   * view
   */
  async getScore(agentId: Hash, provider: Address): Promise<number> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getScore',
      args: [agentId, provider] as any,
    }) as number;
  }

  /**
   * getSettlement
   * view
   */
  async getSettlement(bidId: Hash): Promise<SettlementDetails> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getSettlement',
      args: [bidId] as any,
    }) as SettlementDetails;
  }

  /**
   * getTotalSettled
   * view
   */
  async getTotalSettled(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'getTotalSettled',
      args: [],
    }) as bigint;
  }

  /**
   * isBidCancelled
   * view
   */
  async isBidCancelled(bidId: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'isBidCancelled',
      args: [bidId] as any,
    }) as boolean;
  }

  /**
   * isBidExpired
   * view
   */
  async isBidExpired(bidId: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'isBidExpired',
      args: [bidId] as any,
    }) as boolean;
  }

  /**
   * isNonceUsed
   * view
   */
  async isNonceUsed(nonce: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'isNonceUsed',
      args: [nonce] as any,
    }) as boolean;
  }

  /**
   * postManualBid
   * nonpayable
   */
  async postManualBid(bidAuthorization: BidAuthorization, v: number, r: Hash, s: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'postManualBid',
      args: [bidAuthorization, v, r, s] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * processRefund
   * nonpayable
   */
  async processRefund(bidId: Hash, valid: boolean, refundPercent: number): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'processRefund',
      args: [bidId, valid, refundPercent] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * rateBid
   * nonpayable
   */
  async rateBid(bidId: Hash, positive: boolean, reviewHash: Hex): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'rateBid',
      args: [bidId, positive, reviewHash] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * registerReputationProvider
   * nonpayable
   */
  async registerReputationProvider(provider: ReputationProvider): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'registerReputationProvider',
      args: [provider] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setAttestationManager
   * nonpayable
   */
  async setAttestationManager(_attestationManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setAttestationManager',
      args: [_attestationManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setDisputeWindow
   * nonpayable
   */
  async setDisputeWindow(_disputeWindow: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setDisputeWindow',
      args: [_disputeWindow] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setMinTrustScore
   * nonpayable
   */
  async setMinTrustScore(_minTrustScore: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setMinTrustScore',
      args: [_minTrustScore] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setNetwork
   * nonpayable
   */
  async setNetwork(_network: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setNetwork',
      args: [_network] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setReputationManager
   * nonpayable
   */
  async setReputationManager(_reputationManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setReputationManager',
      args: [_reputationManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setTokenVault
   * nonpayable
   */
  async setTokenVault(_tokenVault: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'setTokenVault',
      args: [_tokenVault] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * settleBid
   * nonpayable
   */
  async settleBid(bidId: Hash, reputationProvider: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'settleBid',
      args: [bidId, reputationProvider] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * submitRating
   * nonpayable
   */
  async submitRating(signature: Hex, record: ReputationRecord): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: IBIDMANAGER_ABI,
      functionName: 'submitRating',
      args: [signature, record] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get AllowedAgentsVerificationFailed event logs
   */
  async getAllowedAgentsVerificationFailedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'AllowedAgentsVerificationFailed'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidAccepted event logs
   */
  async getBidAcceptedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidAccepted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidAudited event logs
   */
  async getBidAuditedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidAudited'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get BidCancelled event logs
   */
  async getBidCancelledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidCancelled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId }
    }) as any[];
  }

  /**
   * Get BidCompleted event logs
   */
  async getBidCompletedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidCompleted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidExpired event logs
   */
  async getBidExpiredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidExpired'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId }
    }) as any[];
  }

  /**
   * Get BidPosted event logs
   */
  async getBidPostedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidPosted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidRated event logs
   */
  async getBidRatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, raterId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidRated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, raterId: options?.raterId }
    }) as any[];
  }

  /**
   * Get BidSettled event logs
   */
  async getBidSettledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, agentId?: Hash, offererId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'BidSettled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, agentId: options?.agentId, offererId: options?.offererId }
    }) as any[];
  }

  /**
   * Get DisputeOpened event logs
   */
  async getDisputeOpenedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'DisputeOpened'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get DisputeResolved event logs
   */
  async getDisputeResolvedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'DisputeResolved'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get RatingSubmitted event logs
   */
  async getRatingSubmittedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'RatingSubmitted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get ReputationProviderRegistered event logs
   */
  async getReputationProviderRegisteredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    providerAddr?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'ReputationProviderRegistered'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { providerAddr: options?.providerAddr }
    }) as any[];
  }

  /**
   * Get TrustScoreCheckFailed event logs
   */
  async getTrustScoreCheckFailedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: IBIDMANAGER_ABI.find(e => e.type === 'event' && e.name === 'TrustScoreCheckFailed'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Watch AllowedAgentsVerificationFailed events
   */
  watchAllowedAgentsVerificationFailed(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'AllowedAgentsVerificationFailed',
      onLogs,
    });
  }

  /**
   * Watch BidAccepted events
   */
  watchBidAccepted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidAccepted',
      onLogs,
    });
  }

  /**
   * Watch BidAudited events
   */
  watchBidAudited(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidAudited',
      onLogs,
    });
  }

  /**
   * Watch BidCancelled events
   */
  watchBidCancelled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidCancelled',
      onLogs,
    });
  }

  /**
   * Watch BidCompleted events
   */
  watchBidCompleted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidCompleted',
      onLogs,
    });
  }

  /**
   * Watch BidExpired events
   */
  watchBidExpired(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidExpired',
      onLogs,
    });
  }

  /**
   * Watch BidPosted events
   */
  watchBidPosted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidPosted',
      onLogs,
    });
  }

  /**
   * Watch BidRated events
   */
  watchBidRated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidRated',
      onLogs,
    });
  }

  /**
   * Watch BidSettled events
   */
  watchBidSettled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'BidSettled',
      onLogs,
    });
  }

  /**
   * Watch DisputeOpened events
   */
  watchDisputeOpened(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'DisputeOpened',
      onLogs,
    });
  }

  /**
   * Watch DisputeResolved events
   */
  watchDisputeResolved(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'DisputeResolved',
      onLogs,
    });
  }

  /**
   * Watch RatingSubmitted events
   */
  watchRatingSubmitted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'RatingSubmitted',
      onLogs,
    });
  }

  /**
   * Watch ReputationProviderRegistered events
   */
  watchReputationProviderRegistered(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'ReputationProviderRegistered',
      onLogs,
    });
  }

  /**
   * Watch TrustScoreCheckFailed events
   */
  watchTrustScoreCheckFailed(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: IBIDMANAGER_ABI,
      eventName: 'TrustScoreCheckFailed',
      onLogs,
    });
  }
}
