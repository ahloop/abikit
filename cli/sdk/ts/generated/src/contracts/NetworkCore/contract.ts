// Auto-generated contract wrapper for NetworkCore
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address, Hex } from 'viem';
import type { BidAuthorization } from '../../types';
import { NETWORKCORE_ABI } from './abi';

export interface NetworkCoreConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class NetworkCore {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: NetworkCoreConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * USDC
   * view
   */
  async USDC(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'USDC',
      args: [],
    }) as Address;
  }

  /**
   * acceptBid
   * nonpayable
   */
  async acceptBid(bidId: Hash, signature: Hex, resultHash: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'acceptBid',
      args: [bidId, signature, resultHash] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * agentManager
   * view
   */
  async agentManager(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'agentManager',
      args: [],
    }) as Address;
  }

  /**
   * attestationManager
   * view
   */
  async attestationManager(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'attestationManager',
      args: [],
    }) as Address;
  }

  /**
   * auditBid
   * nonpayable
   */
  async auditBid(bidId: Hash, valid: boolean, refundPercent: number): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'auditBid',
      args: [bidId, valid, refundPercent] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * authority
   * view
   */
  async authority(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'authority',
      args: [],
    }) as Address;
  }

  /**
   * bidManager
   * view
   */
  async bidManager(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'bidManager',
      args: [],
    }) as Address;
  }

  /**
   * cancelBid
   * nonpayable
   */
  async cancelBid(bidId: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'cancelBid',
      args: [bidId] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * changeAuthority
   * nonpayable
   */
  async changeAuthority(_newAuthority: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'changeAuthority',
      args: [_newAuthority] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * completeBid
   * nonpayable
   */
  async completeBid(bidId: Hash, responseHash: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'completeBid',
      args: [bidId, responseHash] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * getModuleAddresses
   * view
   */
  async getModuleAddresses(): Promise<[Address, Address, Address, Address, Address, Address, Address]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'getModuleAddresses',
      args: [],
    }) as [Address, Address, Address, Address, Address, Address, Address];
  }

  /**
   * getPendingBidAt
   * view
   */
  async getPendingBidAt(agentId: Hash, index: bigint): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'getPendingBidAt',
      args: [agentId, index] as any,
    }) as Hash;
  }

  /**
   * getPendingBidsCount
   * view
   */
  async getPendingBidsCount(agentId: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'getPendingBidsCount',
      args: [agentId] as any,
    }) as bigint;
  }

  /**
   * initializeModules
   * nonpayable
   */
  async initializeModules(_tokenVault: Address, _paymentRouter: Address, _bidManager: Address, _agentManager: Address, _attestationManager: Address, _settlementManager: Address, _reputationManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'initializeModules',
      args: [_tokenVault, _paymentRouter, _bidManager, _agentManager, _attestationManager, _settlementManager, _reputationManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * isAgentVerified
   * view
   */
  async isAgentVerified(agentId: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'isAgentVerified',
      args: [agentId] as any,
    }) as boolean;
  }

  /**
   * isModulesInitialized
   * view
   */
  async isModulesInitialized(): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'isModulesInitialized',
      args: [],
    }) as boolean;
  }

  /**
   * modulesInitialized
   * view
   */
  async modulesInitialized(): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'modulesInitialized',
      args: [],
    }) as boolean;
  }

  /**
   * paymentRouter
   * view
   */
  async paymentRouter(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'paymentRouter',
      args: [],
    }) as Address;
  }

  /**
   * postManualBid
   * nonpayable
   */
  async postManualBid(bidAuthorization: BidAuthorization, v: number, r: Hash, s: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'postManualBid',
      args: [bidAuthorization, v, r, s] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * rateBid
   * nonpayable
   */
  async rateBid(bidId: Hash, positive: boolean, reviewHash: Hex): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'rateBid',
      args: [bidId, positive, reviewHash] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * registerAgent
   * nonpayable
   */
  async registerAgent(agentId: Hash, metadataCallback: string, communicationEndpoint: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'registerAgent',
      args: [agentId, metadataCallback, communicationEndpoint] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * registry
   * view
   */
  async registry(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'registry',
      args: [],
    }) as Address;
  }

  /**
   * reputationManager
   * view
   */
  async reputationManager(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'reputationManager',
      args: [],
    }) as Address;
  }

  /**
   * setAgentManager
   * nonpayable
   */
  async setAgentManager(_agentManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setAgentManager',
      args: [_agentManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setAttestationManager
   * nonpayable
   */
  async setAttestationManager(_attestationManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setAttestationManager',
      args: [_attestationManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setBidManager
   * nonpayable
   */
  async setBidManager(_bidManager: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setBidManager',
      args: [_bidManager] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setDisputeWindow
   * nonpayable
   */
  async setDisputeWindow(_disputeWindow: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setDisputeWindow',
      args: [_disputeWindow] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setPaymentRouter
   * nonpayable
   */
  async setPaymentRouter(_paymentRouter: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setPaymentRouter',
      args: [_paymentRouter] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setRegistry
   * nonpayable
   */
  async setRegistry(_registry: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setRegistry',
      args: [_registry] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setTokenVault
   * nonpayable
   */
  async setTokenVault(_tokenVault: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'setTokenVault',
      args: [_tokenVault] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * settleBid
   * nonpayable
   */
  async settleBid(bidId: Hash, reputationProvider: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'settleBid',
      args: [bidId, reputationProvider] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * settlementManager
   * view
   */
  async settlementManager(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'settlementManager',
      args: [],
    }) as Address;
  }

  /**
   * tokenVault
   * view
   */
  async tokenVault(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'tokenVault',
      args: [],
    }) as Address;
  }

  /**
   * usdc
   * view
   */
  async usdc(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: NETWORKCORE_ABI,
      functionName: 'usdc',
      args: [],
    }) as Address;
  }

  /**
   * Get AgentRegistered event logs
   */
  async getAgentRegisteredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, attestationRoot?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'AgentRegistered'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, attestationRoot: options?.attestationRoot }
    }) as any[];
  }

  /**
   * Get AttestationRootEnabled event logs
   */
  async getAttestationRootEnabledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    rootKey?: Hash, root?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'AttestationRootEnabled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { rootKey: options?.rootKey, root: options?.root }
    }) as any[];
  }

  /**
   * Get AuthorityChanged event logs
   */
  async getAuthorityChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    oldAuthority?: Address, newAuthority?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'AuthorityChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { oldAuthority: options?.oldAuthority, newAuthority: options?.newAuthority }
    }) as any[];
  }

  /**
   * Get BidAccepted event logs
   */
  async getBidAcceptedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidAccepted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidAudited event logs
   */
  async getBidAuditedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidAudited'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId }
    }) as any[];
  }

  /**
   * Get BidCompleted event logs
   */
  async getBidCompletedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidCompleted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidPosted event logs
   */
  async getBidPostedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidPosted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get BidRated event logs
   */
  async getBidRatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, raterId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidRated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, raterId: options?.raterId }
    }) as any[];
  }

  /**
   * Get BidSettled event logs
   */
  async getBidSettledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, offererId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'BidSettled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, offererId: options?.offererId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get Initialized event logs
   */
  async getInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'Initialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get ModuleAddressSet event logs
   */
  async getModuleAddressSetLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    oldAddress?: Address, newAddress?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'ModuleAddressSet'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { oldAddress: options?.oldAddress, newAddress: options?.newAddress }
    }) as any[];
  }

  /**
   * Get ModulesInitialized event logs
   */
  async getModulesInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'ModulesInitialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get RatingSubmitted event logs
   */
  async getRatingSubmittedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, bidId?: Hash, nonce?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'RatingSubmitted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, bidId: options?.bidId, nonce: options?.nonce }
    }) as any[];
  }

  /**
   * Get ReputationConsolidated event logs
   */
  async getReputationConsolidatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, stateRoot?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'ReputationConsolidated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, stateRoot: options?.stateRoot }
    }) as any[];
  }

  /**
   * Get ReputationProviderRegistered event logs
   */
  async getReputationProviderRegisteredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    providerAddr?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: NETWORKCORE_ABI.find(e => e.type === 'event' && e.name === 'ReputationProviderRegistered'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { providerAddr: options?.providerAddr }
    }) as any[];
  }

  /**
   * Watch AgentRegistered events
   */
  watchAgentRegistered(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'AgentRegistered',
      onLogs,
    });
  }

  /**
   * Watch AttestationRootEnabled events
   */
  watchAttestationRootEnabled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'AttestationRootEnabled',
      onLogs,
    });
  }

  /**
   * Watch AuthorityChanged events
   */
  watchAuthorityChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'AuthorityChanged',
      onLogs,
    });
  }

  /**
   * Watch BidAccepted events
   */
  watchBidAccepted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidAccepted',
      onLogs,
    });
  }

  /**
   * Watch BidAudited events
   */
  watchBidAudited(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidAudited',
      onLogs,
    });
  }

  /**
   * Watch BidCompleted events
   */
  watchBidCompleted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidCompleted',
      onLogs,
    });
  }

  /**
   * Watch BidPosted events
   */
  watchBidPosted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidPosted',
      onLogs,
    });
  }

  /**
   * Watch BidRated events
   */
  watchBidRated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidRated',
      onLogs,
    });
  }

  /**
   * Watch BidSettled events
   */
  watchBidSettled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'BidSettled',
      onLogs,
    });
  }

  /**
   * Watch Initialized events
   */
  watchInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'Initialized',
      onLogs,
    });
  }

  /**
   * Watch ModuleAddressSet events
   */
  watchModuleAddressSet(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'ModuleAddressSet',
      onLogs,
    });
  }

  /**
   * Watch ModulesInitialized events
   */
  watchModulesInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'ModulesInitialized',
      onLogs,
    });
  }

  /**
   * Watch RatingSubmitted events
   */
  watchRatingSubmitted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'RatingSubmitted',
      onLogs,
    });
  }

  /**
   * Watch ReputationConsolidated events
   */
  watchReputationConsolidated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'ReputationConsolidated',
      onLogs,
    });
  }

  /**
   * Watch ReputationProviderRegistered events
   */
  watchReputationProviderRegistered(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: NETWORKCORE_ABI,
      eventName: 'ReputationProviderRegistered',
      onLogs,
    });
  }
}
