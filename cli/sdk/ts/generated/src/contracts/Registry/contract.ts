// Auto-generated contract wrapper for Registry
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address } from 'viem';
import type { ReputationRecord, AgentConfig } from '../../types';
import { REGISTRY_ABI } from './abi';

export interface RegistryConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class Registry {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: RegistryConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * attestationRootExists
   * view
   */
  async attestationRootExists(rootKey: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'attestationRootExists',
      args: [rootKey] as any,
    }) as boolean;
  }

  /**
   * authority
   * view
   */
  async authority(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'authority',
      args: [],
    }) as Address;
  }

  /**
   * changeAuthority
   * nonpayable
   */
  async changeAuthority(_newAuthority: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'changeAuthority',
      args: [_newAuthority] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * disableAgent
   * nonpayable
   */
  async disableAgent(agentId_: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'disableAgent',
      args: [agentId_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * disableRoot
   * nonpayable
   */
  async disableRoot(rootKey: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'disableRoot',
      args: [rootKey] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * enableAttestationRoot
   * nonpayable
   */
  async enableAttestationRoot(rootKey: Hash, initialRoot: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'enableAttestationRoot',
      args: [rootKey, initialRoot] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * getAgent
   * view
   */
  async getAgent(agentId_: Hash): Promise<[Hash, Hash, string, string, string, boolean]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAgent',
      args: [agentId_] as any,
    }) as [Hash, Hash, string, string, string, boolean];
  }

  /**
   * getAgentOwner
   * view
   */
  async getAgentOwner(agentId_: Hash): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAgentOwner',
      args: [agentId_] as any,
    }) as Address;
  }

  /**
   * getAgentRatingCount
   * view
   */
  async getAgentRatingCount(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAgentRatingCount',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAgentRatingData
   * view
   */
  async getAgentRatingData(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAgentRatingData',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAgentReputationScore
   * view
   */
  async getAgentReputationScore(agentId_: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAgentReputationScore',
      args: [agentId_] as any,
    }) as bigint;
  }

  /**
   * getAttestationRoot
   * view
   */
  async getAttestationRoot(rootKey: Hash): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getAttestationRoot',
      args: [rootKey] as any,
    }) as Hash;
  }

  /**
   * getBidRating
   * view
   */
  async getBidRating(bidId_: Hash): Promise<ReputationRecord> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'getBidRating',
      args: [bidId_] as any,
    }) as ReputationRecord;
  }

  /**
   * isAgentActive
   * view
   */
  async isAgentActive(agentId_: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'isAgentActive',
      args: [agentId_] as any,
    }) as boolean;
  }

  /**
   * isAgentAttestationVerified
   * view
   */
  async isAgentAttestationVerified(agentId: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'isAgentAttestationVerified',
      args: [agentId] as any,
    }) as boolean;
  }

  /**
   * isAgentRegistered
   * view
   */
  async isAgentRegistered(agentId_: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'isAgentRegistered',
      args: [agentId_] as any,
    }) as boolean;
  }

  /**
   * isBidRated
   * view
   */
  async isBidRated(bidId_: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'isBidRated',
      args: [bidId_] as any,
    }) as boolean;
  }

  /**
   * isSerialVerified
   * view
   */
  async isSerialVerified(serial: Hash): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'isSerialVerified',
      args: [serial] as any,
    }) as boolean;
  }

  /**
   * registerAgent
   * nonpayable
   */
  async registerAgent(agentId_: Hash, config_: AgentConfig, attestationRoot_: Hash, proof_: Hash[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'registerAgent',
      args: [agentId_, config_, attestationRoot_, proof_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setNetwork
   * nonpayable
   */
  async setNetwork(_network: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'setNetwork',
      args: [_network] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setReputationProvider
   * nonpayable
   */
  async setReputationProvider(agentId_: Hash, provider_: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'setReputationProvider',
      args: [agentId_, provider_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * submitDetailedRating
   * nonpayable
   */
  async submitDetailedRating(bidId_: Hash, agentId_: Hash, score: number, comment: string, tags: number[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'submitDetailedRating',
      args: [bidId_, agentId_, score, comment, tags] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * submitRating
   * nonpayable
   */
  async submitRating(bidId_: Hash, agentId_: Hash, score: number, comment: string): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'submitRating',
      args: [bidId_, agentId_, score, comment] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * trackAgentAttestation
   * nonpayable
   */
  async trackAgentAttestation(agentId_: Hash, attestationRoot_: Hash, proof_: Hash[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'trackAgentAttestation',
      args: [agentId_, attestationRoot_, proof_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * transferAgent
   * nonpayable
   */
  async transferAgent(agentId_: Hash, newOwner_: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'transferAgent',
      args: [agentId_, newOwner_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * updateAgent
   * nonpayable
   */
  async updateAgent(agentId_: Hash, config_: AgentConfig): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'updateAgent',
      args: [agentId_, config_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * validateAndTrackAttestation
   * nonpayable
   */
  async validateAndTrackAttestation(agentId: Hash, attestationRoot: Hash, proof: Hash[]): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: REGISTRY_ABI,
      functionName: 'validateAndTrackAttestation',
      args: [agentId, attestationRoot, proof] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get AgentOwnershipTransferred event logs
   */
  async getAgentOwnershipTransferredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, oldOwner?: Address, newOwner?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AgentOwnershipTransferred'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, oldOwner: options?.oldOwner, newOwner: options?.newOwner }
    }) as any[];
  }

  /**
   * Get AgentRatingCountUpdated event logs
   */
  async getAgentRatingCountUpdatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AgentRatingCountUpdated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get AgentRegistered event logs
   */
  async getAgentRegisteredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, operator?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AgentRegistered'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, operator: options?.operator }
    }) as any[];
  }

  /**
   * Get AttestationRootEnabled event logs
   */
  async getAttestationRootEnabledLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    rootKey?: Hash, root?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AttestationRootEnabled'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { rootKey: options?.rootKey, root: options?.root }
    }) as any[];
  }

  /**
   * Get AttestationVerified event logs
   */
  async getAttestationVerifiedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash, rootKey?: Hash, serial?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AttestationVerified'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId, rootKey: options?.rootKey, serial: options?.serial }
    }) as any[];
  }

  /**
   * Get AuthorityChanged event logs
   */
  async getAuthorityChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    oldAuthority?: Address, newAuthority?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'AuthorityChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { oldAuthority: options?.oldAuthority, newAuthority: options?.newAuthority }
    }) as any[];
  }

  /**
   * Get Initialized event logs
   */
  async getInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'Initialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get NetworkSet event logs
   */
  async getNetworkSetLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    network?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'NetworkSet'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { network: options?.network }
    }) as any[];
  }

  /**
   * Get RatingSubmitted event logs
   */
  async getRatingSubmittedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    bidId?: Hash, agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'RatingSubmitted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { bidId: options?.bidId, agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Get ReputationProviderSet event logs
   */
  async getReputationProviderSetLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    agentId?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: REGISTRY_ABI.find(e => e.type === 'event' && e.name === 'ReputationProviderSet'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { agentId: options?.agentId }
    }) as any[];
  }

  /**
   * Watch AgentOwnershipTransferred events
   */
  watchAgentOwnershipTransferred(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AgentOwnershipTransferred',
      onLogs,
    });
  }

  /**
   * Watch AgentRatingCountUpdated events
   */
  watchAgentRatingCountUpdated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AgentRatingCountUpdated',
      onLogs,
    });
  }

  /**
   * Watch AgentRegistered events
   */
  watchAgentRegistered(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AgentRegistered',
      onLogs,
    });
  }

  /**
   * Watch AttestationRootEnabled events
   */
  watchAttestationRootEnabled(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AttestationRootEnabled',
      onLogs,
    });
  }

  /**
   * Watch AttestationVerified events
   */
  watchAttestationVerified(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AttestationVerified',
      onLogs,
    });
  }

  /**
   * Watch AuthorityChanged events
   */
  watchAuthorityChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'AuthorityChanged',
      onLogs,
    });
  }

  /**
   * Watch Initialized events
   */
  watchInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'Initialized',
      onLogs,
    });
  }

  /**
   * Watch NetworkSet events
   */
  watchNetworkSet(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'NetworkSet',
      onLogs,
    });
  }

  /**
   * Watch RatingSubmitted events
   */
  watchRatingSubmitted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'RatingSubmitted',
      onLogs,
    });
  }

  /**
   * Watch ReputationProviderSet events
   */
  watchReputationProviderSet(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: REGISTRY_ABI,
      eventName: 'ReputationProviderSet',
      onLogs,
    });
  }
}
