// Auto-generated contract wrapper for Token
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address } from 'viem';

import { TOKEN_ABI } from './abi';

export interface TokenConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class Token {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: TokenConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * DOMAIN_SEPARATOR
   * view
   */
  async DOMAIN_SEPARATOR(): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'DOMAIN_SEPARATOR',
      args: [],
    }) as Hash;
  }

  /**
   * allowance
   * view
   */
  async allowance(owner: Address, spender: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'allowance',
      args: [owner, spender] as any,
    }) as bigint;
  }

  /**
   * approve
   * nonpayable
   */
  async approve(spender: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'approve',
      args: [spender, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * approved
   * view
   */
  async approved(arg0: Address): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'approved',
      args: [arg0] as any,
    }) as boolean;
  }

  /**
   * balanceOf
   * view
   */
  async balanceOf(account: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'balanceOf',
      args: [account] as any,
    }) as bigint;
  }

  /**
   * burn
   * nonpayable
   */
  async burn(from: Address, amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'burn',
      args: [from, amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * decimals
   * view
   */
  async decimals(): Promise<number> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'decimals',
      args: [],
    }) as number;
  }

  /**
   * eip712Domain
   * view
   */
  async eip712Domain(): Promise<[unknown, string, string, bigint, Address, Hash, bigint[]]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'eip712Domain',
      args: [],
    }) as [unknown, string, string, bigint, Address, Hash, bigint[]];
  }

  /**
   * initialize
   * nonpayable
   */
  async initialize(_owner: Address, _network: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'initialize',
      args: [_owner, _network] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * mint
   * nonpayable
   */
  async mint(to: Address, amount: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'mint',
      args: [to, amount] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * name
   * view
   */
  async name(): Promise<string> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'name',
      args: [],
    }) as string;
  }

  /**
   * network
   * view
   */
  async network(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'network',
      args: [],
    }) as Address;
  }

  /**
   * nonces
   * view
   */
  async nonces(owner: Address): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'nonces',
      args: [owner] as any,
    }) as bigint;
  }

  /**
   * owner
   * view
   */
  async owner(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'owner',
      args: [],
    }) as Address;
  }

  /**
   * permit
   * nonpayable
   */
  async permit(owner: Address, spender: Address, value: bigint, deadline: bigint, v: number, r: Hash, s: Hash): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'permit',
      args: [owner, spender, value, deadline, v, r, s] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * renounceOwnership
   * nonpayable
   */
  async renounceOwnership(): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'renounceOwnership',
      args: [],
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * symbol
   * view
   */
  async symbol(): Promise<string> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'symbol',
      args: [],
    }) as string;
  }

  /**
   * totalSupply
   * view
   */
  async totalSupply(): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'totalSupply',
      args: [],
    }) as bigint;
  }

  /**
   * transfer
   * nonpayable
   */
  async transfer(to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'transfer',
      args: [to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * transferFrom
   * nonpayable
   */
  async transferFrom(from: Address, to: Address, value: bigint): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'transferFrom',
      args: [from, to, value] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * transferOwnership
   * nonpayable
   */
  async transferOwnership(newOwner: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'transferOwnership',
      args: [newOwner] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * updateWhitelist
   * nonpayable
   */
  async updateWhitelist(_address: Address, _approved: boolean): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: TOKEN_ABI,
      functionName: 'updateWhitelist',
      args: [_address, _approved] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get Approval event logs
   */
  async getApprovalLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    owner?: Address, spender?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'Approval'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { owner: options?.owner, spender: options?.spender }
    }) as any[];
  }

  /**
   * Get EIP712DomainChanged event logs
   */
  async getEIP712DomainChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'EIP712DomainChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get Initialized event logs
   */
  async getInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'Initialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get OwnershipTransferred event logs
   */
  async getOwnershipTransferredLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    previousOwner?: Address, newOwner?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'OwnershipTransferred'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { previousOwner: options?.previousOwner, newOwner: options?.newOwner }
    }) as any[];
  }

  /**
   * Get Transfer event logs
   */
  async getTransferLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    from?: Address, to?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'Transfer'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { from: options?.from, to: options?.to }
    }) as any[];
  }

  /**
   * Get WhitelistUpdated event logs
   */
  async getWhitelistUpdatedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    approved?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: TOKEN_ABI.find(e => e.type === 'event' && e.name === 'WhitelistUpdated'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { approved: options?.approved }
    }) as any[];
  }

  /**
   * Watch Approval events
   */
  watchApproval(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'Approval',
      onLogs,
    });
  }

  /**
   * Watch EIP712DomainChanged events
   */
  watchEIP712DomainChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'EIP712DomainChanged',
      onLogs,
    });
  }

  /**
   * Watch Initialized events
   */
  watchInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'Initialized',
      onLogs,
    });
  }

  /**
   * Watch OwnershipTransferred events
   */
  watchOwnershipTransferred(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'OwnershipTransferred',
      onLogs,
    });
  }

  /**
   * Watch Transfer events
   */
  watchTransfer(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'Transfer',
      onLogs,
    });
  }

  /**
   * Watch WhitelistUpdated events
   */
  watchWhitelistUpdated(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: TOKEN_ABI,
      eventName: 'WhitelistUpdated',
      onLogs,
    });
  }
}
