// Auto-generated contract wrapper for Authority
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
import type { Hash, Address } from 'viem';

import { AUTHORITY_ABI } from './abi';

export interface AuthorityConfig {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class Authority {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: AuthorityConfig) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

  /**
   * BASE_ROLE
   * view
   */
  async BASE_ROLE(): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'BASE_ROLE',
      args: [],
    }) as Hash;
  }

  /**
   * DEFAULT_ADMIN_ROLE
   * view
   */
  async DEFAULT_ADMIN_ROLE(): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'DEFAULT_ADMIN_ROLE',
      args: [],
    }) as Hash;
  }

  /**
   * authority
   * view
   */
  async authority(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'authority',
      args: [],
    }) as Address;
  }

  /**
   * changeAuthority
   * nonpayable
   */
  async changeAuthority(_newAuthority: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'changeAuthority',
      args: [_newAuthority] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * getRoleAdmin
   * view
   */
  async getRoleAdmin(role: Hash): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'getRoleAdmin',
      args: [role] as any,
    }) as Hash;
  }

  /**
   * getRoleHash
   * pure
   */
  async getRoleHash(role_: number): Promise<Hash> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'getRoleHash',
      args: [role_] as any,
    }) as Hash;
  }

  /**
   * getRoleMember
   * view
   */
  async getRoleMember(role: Hash, index: bigint): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'getRoleMember',
      args: [role, index] as any,
    }) as Address;
  }

  /**
   * getRoleMemberCount
   * view
   */
  async getRoleMemberCount(role: Hash): Promise<bigint> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'getRoleMemberCount',
      args: [role] as any,
    }) as bigint;
  }

  /**
   * getRoleMembers
   * view
   */
  async getRoleMembers(role: Hash): Promise<Address[]> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'getRoleMembers',
      args: [role] as any,
    }) as Address[];
  }

  /**
   * grantRole
   * nonpayable
   */
  async grantRole(role: Hash, account: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'grantRole',
      args: [role, account] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * hasRole
   * view
   */
  async hasRole(role: Hash, account: Address): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'hasRole',
      args: [role, account] as any,
    }) as boolean;
  }

  /**
   * isRole
   * view
   */
  async isRole(role_: Hash, sender_: Address): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'isRole',
      args: [role_, sender_] as any,
    }) as boolean;
  }

  /**
   * operator
   * view
   */
  async operator(): Promise<Address> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'operator',
      args: [],
    }) as Address;
  }

  /**
   * removeRole
   * nonpayable
   */
  async removeRole(role_: Hash, sender_: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'removeRole',
      args: [role_, sender_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * renounceRole
   * nonpayable
   */
  async renounceRole(role: Hash, callerConfirmation: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'renounceRole',
      args: [role, callerConfirmation] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * revokeRole
   * nonpayable
   */
  async revokeRole(role: Hash, account: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'revokeRole',
      args: [role, account] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * setRole
   * nonpayable
   */
  async setRole(role_: Hash, sender_: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'setRole',
      args: [role_, sender_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * supportsInterface
   * view
   */
  async supportsInterface(interfaceId: unknown): Promise<boolean> {
    if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'supportsInterface',
      args: [interfaceId] as any,
    }) as boolean;
  }

  /**
   * transferOwnership
   * nonpayable
   */
  async transferOwnership(newOperator_: Address): Promise<Hash> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: AUTHORITY_ABI,
      functionName: 'transferOwnership',
      args: [newOperator_] as any,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }

  /**
   * Get AuthorityChanged event logs
   */
  async getAuthorityChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    oldAuthority?: Address, newAuthority?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'AuthorityChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { oldAuthority: options?.oldAuthority, newAuthority: options?.newAuthority }
    }) as any[];
  }

  /**
   * Get Initialized event logs
   */
  async getInitializedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'Initialized'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      
    }) as any[];
  }

  /**
   * Get OperatorChanged event logs
   */
  async getOperatorChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    oldOperator?: Address, newOperator?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'OperatorChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { oldOperator: options?.oldOperator, newOperator: options?.newOperator }
    }) as any[];
  }

  /**
   * Get RoleAdminChanged event logs
   */
  async getRoleAdminChangedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    role?: Hash, previousAdminRole?: Hash, newAdminRole?: Hash;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'RoleAdminChanged'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { role: options?.role, previousAdminRole: options?.previousAdminRole, newAdminRole: options?.newAdminRole }
    }) as any[];
  }

  /**
   * Get RoleGranted event logs
   */
  async getRoleGrantedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    role?: Hash, account?: Address, sender?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'RoleGranted'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { role: options?.role, account: options?.account, sender: options?.sender }
    }) as any[];
  }

  /**
   * Get RoleRevoked event logs
   */
  async getRoleRevokedLogs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    role?: Hash, account?: Address, sender?: Address;
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: AUTHORITY_ABI.find(e => e.type === 'event' && e.name === 'RoleRevoked'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      args: { role: options?.role, account: options?.account, sender: options?.sender }
    }) as any[];
  }

  /**
   * Watch AuthorityChanged events
   */
  watchAuthorityChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'AuthorityChanged',
      onLogs,
    });
  }

  /**
   * Watch Initialized events
   */
  watchInitialized(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'Initialized',
      onLogs,
    });
  }

  /**
   * Watch OperatorChanged events
   */
  watchOperatorChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'OperatorChanged',
      onLogs,
    });
  }

  /**
   * Watch RoleAdminChanged events
   */
  watchRoleAdminChanged(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'RoleAdminChanged',
      onLogs,
    });
  }

  /**
   * Watch RoleGranted events
   */
  watchRoleGranted(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'RoleGranted',
      onLogs,
    });
  }

  /**
   * Watch RoleRevoked events
   */
  watchRoleRevoked(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: AUTHORITY_ABI,
      eventName: 'RoleRevoked',
      onLogs,
    });
  }
}
