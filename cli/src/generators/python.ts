/**
 * Python SDK generator (web3.py + Pydantic)
 */

import { BaseGenerator } from './base';
import { ContractGraph, ContractModel, Parameter } from '../types/model';
import { TargetConfig, PythonTargetOptions } from '../types/config';

export class PythonGenerator extends BaseGenerator {
    protected options: PythonTargetOptions;

    constructor(outDir: string, options: PythonTargetOptions = {}) {
        super(outDir, options);
        this.options = {
            emitAsync: false,
            pydanticVersion: 2,
            strictTypes: true,
            packageName: 'contract_sdk',
            format: 'black',
            lint: 'ruff',
            ...options,
        };
    }

    getName(): string {
        return 'Python Generator (web3.py + Pydantic)';
    }

    validateOptions(options: any): void {
        if (options.pydanticVersion && options.pydanticVersion !== 2) {
            throw new Error('Only Pydantic v2 is supported');
        }
    }

    async generate(graph: ContractGraph, _config: TargetConfig): Promise<void> {
        this.ensureOutDir();
        this.log('Generating Python SDK with web3.py + Pydantic...');

        // Generate contracts
        for (const [_contractName, contract] of graph.contracts.entries()) {
            this.generateContractModule(contract);
        }

        // Generate runtime
        this.generateRuntime();

        // Generate config files
        this.generateConfigFiles(graph);

        // Generate pyproject.toml
        this.generatePyprojectToml();

        // Generate __init__.py
        this.generateInit(graph);

        this.logSuccess(`Generated Python SDK to ${this.outDir}`);
    }

    /**
     * Generate contract module
     */
    private generateContractModule(contract: ContractModel): void {
        const moduleName = this.toSnakeCase(contract.name);
        const content = this.renderContractTemplate(contract);
        this.writeFile(`contracts/${moduleName}/${moduleName}.py`, content);

        // Generate types
        const typesContent = this.renderTypesTemplate(contract);
        this.writeFile(`contracts/${moduleName}/types.py`, typesContent);

        // Generate __init__.py
        this.writeFile(`contracts/${moduleName}/__init__.py`,
            `from .${moduleName} import ${contract.name}\nfrom .types import *\n`);
    }

    /**
     * Render contract template
     */
    private renderContractTemplate(contract: ContractModel): string {
        return `"""
Auto-generated contract wrapper for ${contract.name}
Generated by contract-sdk-gen
"""

from typing import Optional
from web3 import Web3
from web3.contract import Contract
from .types import *

class ${contract.name}:
    """${contract.natspec?.notice || contract.name + ' contract'}"""
    
    def __init__(self, web3: Web3, address: str):
        self.web3 = web3
        self.address = Web3.to_checksum_address(address)
        self.contract = web3.eth.contract(address=self.address, abi=ABI)

${contract.functions.map(func => this.renderPythonMethod(func)).join('\n\n')}

# Contract ABI
ABI = ${JSON.stringify(contract.abi, null, 4)}
`;
    }

    /**
     * Render Python method
     */
    private renderPythonMethod(func: any): string {
        const methodName = this.toSnakeCase(func.name);
        const params = func.inputs.map((input: Parameter) =>
            `${this.toSnakeCase(input.name || 'arg')}: ${this.mapSolidityTypeToPython(input)}`
        ).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';

        return `    def ${methodName}(self${params ? ', ' + params : ''}):
        """${func.name}"""
        ${isReadOnly
                ? `return self.contract.functions.${func.name}(${func.inputs.map((i: Parameter) => this.toSnakeCase(i.name || 'arg')).join(', ')}).call()`
                : `tx = self.contract.functions.${func.name}(${func.inputs.map((i: Parameter) => this.toSnakeCase(i.name || 'arg')).join(', ')}).transact()
        return tx`
            }`;
    }

    /**
     * Map Solidity type to Python type
     */
    private mapSolidityTypeToPython(param: Parameter): string {
        const { type } = param;

        if (type.endsWith('[]')) {
            const baseType = type.slice(0, -2);
            return `list[${this.mapSolidityTypeToPython({ ...param, type: baseType })}]`;
        }

        if (type === 'tuple') {
            const structName = this.extractStructName(param.internalType);
            if (structName) {
                return structName;
            }
            return 'dict';
        }

        const typeMap: Record<string, string> = {
            'address': 'str',
            'bool': 'bool',
            'string': 'str',
            'bytes': 'bytes',
            'bytes32': 'bytes',
            'uint8': 'int',
            'uint16': 'int',
            'uint32': 'int',
            'uint48': 'int',
            'uint64': 'int',
            'uint128': 'int',
            'uint160': 'int',
            'uint256': 'int',
            'int256': 'int',
        };

        return typeMap[type] || 'any';
    }

    /**
     * Render types template for Python
     */
    private renderTypesTemplate(contract: ContractModel): string {
        if (contract.structs.length === 0) {
            return '# No custom types\n';
        }

        return `"""
Auto-generated types for ${contract.name}
Generated by contract-sdk-gen
"""

from pydantic import BaseModel

${contract.structs.map(struct => `
class ${struct.name}(BaseModel):
    """${struct.name} struct"""
${struct.fields.map(field => `    ${this.toSnakeCase(field.name)}: ${this.mapSolidityTypeToPython(field)}`).join('\n')}
`).join('\n')}
`;
    }

    /**
     * Convert to snake_case
     */
    private toSnakeCase(str: string): string {
        return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
    }

    /**
     * Extract struct name
     */
    private extractStructName(internalType?: string): string | null {
        if (!internalType || !internalType.includes('struct ')) {
            return null;
        }
        const match = internalType.match(/struct\s+([^\s\[\]]+)/);
        if (match) {
            const fullName = match[1];
            return fullName.includes('.') ? fullName.split('.').pop()! : fullName;
        }
        return null;
    }

    /**
     * Generate runtime helpers
     */
    private generateRuntime(): void {
        this.log('Generating Python runtime...');
        // TODO: Generate runtime helpers
    }

    /**
     * Generate config files
     */
    private generateConfigFiles(_graph: ContractGraph): void {
        this.log('Generating config files...');
        // TODO: Generate addresses.py and networks.py
    }

    /**
     * Generate pyproject.toml
     */
    private generatePyprojectToml(): void {
        const content = `[tool.poetry]
name = "${this.options.packageName || 'contract-sdk'}"
version = "${this.options.packageVersion || '1.0.0'}"
description = "Auto-generated SDK for smart contracts"
authors = []

[tool.poetry.dependencies]
python = "^3.9"
web3 = "^6.0.0"
pydantic = "^2.0.0"

[tool.poetry.dev-dependencies]
pytest = "^7.0.0"
black = "^23.0.0"
ruff = "^0.1.0"
mypy = "^1.0.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
`;
        this.writeFile('pyproject.toml', content);
    }

    /**
     * Generate __init__.py
     */
    private generateInit(graph: ContractGraph): void {
        const imports = Array.from(graph.contracts.keys())
            .map(name => {
                const moduleName = this.toSnakeCase(name);
                return `from .contracts.${moduleName} import ${name}`;
            })
            .join('\n');

        this.writeFile('__init__.py', `"""Contract SDK"""\n\n${imports}\n`);
    }
}

