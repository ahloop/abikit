/**
 * Python SDK generator (web3.py + Pydantic)
 */

import { BaseGenerator, GeneratorContext } from './base';
import { ContractGraph, ContractModel, Parameter } from '../types/model';
import { TargetConfig, PythonTargetOptions, SignatureItem } from '../types/config';

export class PythonGenerator extends BaseGenerator {
    protected options: PythonTargetOptions;

    constructor(outDir: string, options: PythonTargetOptions = {}) {
        super(outDir, options);
        this.options = {
            emitAsync: false,
            pydanticVersion: 2,
            strictTypes: true,
            packageName: 'contract_sdk',
            format: 'black',
            lint: 'ruff',
            ...options,
        };
    }

    getName(): string {
        return 'Python Generator (web3.py + Pydantic)';
    }

    validateOptions(options: any): void {
        if (options.pydanticVersion && options.pydanticVersion !== 2) {
            throw new Error('Only Pydantic v2 is supported');
        }
    }

    async generate(graph: ContractGraph, _config: TargetConfig, context: GeneratorContext): Promise<void> {
        this.ensureOutDir();
        this.log('Generating Python SDK with web3.py + Pydantic...');

        // Separate contracts from interfaces
        const contracts: ContractModel[] = [];
        const interfaces: ContractModel[] = [];

        for (const [_contractName, contract] of graph.contracts.entries()) {
            if (contract.isInterface) {
                interfaces.push(contract);
            } else {
                contracts.push(contract);
            }
        }

        // Generate contracts
        for (const contract of contracts) {
            this.generateContractModule(contract, 'contracts');
        }

        // Generate interfaces
        for (const interface_ of interfaces) {
            this.generateContractModule(interface_, 'interfaces');
        }

        // Generate centralized types
        this.generateCentralizedTypes(graph);

        // Generate config package
        this.generateConfigPackage(graph, context);

        // Generate signatures if enabled (always generate, even without contracts)
        if (context.signatures?.enabled && context.signatures.items?.length) {
            this.generateSignatures(context.signatures.items, graph);
        }

        // Generate pyproject.toml
        this.generatePyprojectToml();

        // Generate __init__.py
        this.generateInit(graph);

        this.logSuccess(`Generated Python SDK to ${this.outDir}`);
    }

    /**
     * Generate contract module
     */
    private generateContractModule(contract: ContractModel, folder: 'contracts' | 'interfaces'): void {
        const moduleName = this.toSnakeCase(contract.name);

        // Generate contract class file
        const content = this.renderContractTemplate(contract);
        this.writeFile(`${folder}/${moduleName}/${moduleName}.py`, content);

        // Generate separate ABI file
        this.generateAbiFile(contract, folder, moduleName);

        // Generate __init__.py
        this.writeFile(`${folder}/${moduleName}/__init__.py`,
            `from .${moduleName} import ${contract.name}\nfrom .abi import ABI\n`);
    }

    /**
     * Generate separate ABI file
     */
    private generateAbiFile(contract: ContractModel, folder: string, moduleName: string): void {
        // Convert JavaScript boolean values to Python boolean values
        const abiString = JSON.stringify(contract.abi, null, 4)
            .replace(/\btrue\b/g, 'True')
            .replace(/\bfalse\b/g, 'False');

        const content = `"""
Auto-generated ABI for ${contract.name}
Generated by contract-sdk-gen
"""

# Contract ABI
ABI = ${abiString}
`;
        this.writeFile(`${folder}/${moduleName}/abi.py`, content);
    }

    /**
     * Render contract template
     */
    private renderContractTemplate(contract: ContractModel): string {
        return `"""
Auto-generated contract wrapper for ${contract.name}
Generated by contract-sdk-gen
"""

from typing import Optional
from web3 import Web3
from web3.contract import Contract
from .abi import ABI

class ${contract.name}:
    """${contract.natspec?.notice || contract.name + ' contract'}"""
    
    def __init__(self, web3: Web3, address: str):
        self.web3 = web3
        self.address = Web3.to_checksum_address(address)
        self.contract = web3.eth.contract(address=self.address, abi=ABI)

${contract.functions.map(func => this.renderPythonMethod(func)).join('\n\n')}
`;
    }

    /**
     * Render Python method
     */
    private renderPythonMethod(func: any): string {
        const methodName = this.toSnakeCase(func.name);

        // Generate unique parameter names
        const paramNames: string[] = [];
        const params = func.inputs.map((input: Parameter, index: number) => {
            let paramName: string;
            if (input.name) {
                paramName = this.toSnakeCase(input.name);
            } else {
                paramName = `arg${index}`;
            }
            const safeParamName = this.makePythonSafeParamName(paramName);
            paramNames.push(safeParamName);
            return `${safeParamName}: ${this.mapSolidityTypeToPython(input)}`;
        }).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
        const callParams = paramNames.join(', ');

        return `    def ${methodName}(self${params ? ', ' + params : ''}):
        """${func.name}"""
        ${isReadOnly
                ? `return self.contract.functions.${func.name}(${callParams}).call()`
                : `tx = self.contract.functions.${func.name}(${callParams}).transact()
        return tx`
            }`;
    }

    /**
     * Make parameter name Python-safe (avoid reserved keywords)
     */
    private makePythonSafeParamName(name: string): string {
        const reservedKeywords = new Set([
            'from', 'import', 'class', 'def', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally',
            'with', 'as', 'pass', 'break', 'continue', 'return', 'yield', 'lambda', 'and', 'or', 'not', 'in',
            'is', 'global', 'nonlocal', 'assert', 'del', 'exec', 'print', 'raise', 'True', 'False', 'None'
        ]);

        if (reservedKeywords.has(name)) {
            return `${name}_param`;
        }
        return name;
    }

    /**
     * Map Solidity type to Python type
     */
    private mapSolidityTypeToPython(param: Parameter): string {
        const { type } = param;

        if (type.endsWith('[]')) {
            const baseType = type.slice(0, -2);
            return `list[${this.mapSolidityTypeToPython({ ...param, type: baseType })}]`;
        }

        if (type === 'tuple') {
            const structName = this.extractStructName(param.internalType);
            if (structName) {
                // Use string annotation for forward reference
                return `'${structName}'`;
            }
            return 'dict';
        }

        const typeMap: Record<string, string> = {
            'address': 'str',
            'bool': 'bool',
            'string': 'str',
            'bytes': 'bytes',
            'bytes32': 'bytes',
            'uint8': 'int',
            'uint16': 'int',
            'uint32': 'int',
            'uint48': 'int',
            'uint64': 'int',
            'uint128': 'int',
            'uint160': 'int',
            'uint256': 'int',
            'int256': 'int',
        };

        return typeMap[type] || 'any';
    }

    /**
     * Generate centralized types package
     */
    private generateCentralizedTypes(graph: ContractGraph): void {
        this.log('Generating centralized types...');

        // Collect all structs from all contracts and deduplicate
        const allStructs = new Map<string, any>();

        for (const [_contractName, contract] of graph.contracts.entries()) {
            for (const struct of contract.structs) {
                if (!allStructs.has(struct.name)) {
                    allStructs.set(struct.name, struct);
                }
            }
        }

        if (allStructs.size === 0) {
            // Create empty types package
            this.writeFile('types/__init__.py', '"""\nAuto-generated types\nGenerated by contract-sdk-gen\n"""\n\n# No custom types\n');
            return;
        }

        // Generate types content
        const typesContent = `"""
Auto-generated types
Generated by contract-sdk-gen
"""

from pydantic import BaseModel
from typing import List, Optional

${Array.from(allStructs.values()).map(struct => `
class ${struct.name}(BaseModel):
    """${struct.name} struct"""
${struct.fields.map((field: Parameter) => `    ${this.toSnakeCase(field.name)}: ${this.mapSolidityTypeToPython(field)}`).join('\n')}
`).join('\n')}
`;

        this.writeFile('types/__init__.py', typesContent);
    }

    /**
     * Convert to snake_case
     */
    private toSnakeCase(str: string): string {
        return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
    }

    /**
     * Extract struct name
     */
    private extractStructName(internalType?: string): string | null {
        if (!internalType || !internalType.includes('struct ')) {
            return null;
        }
        const match = internalType.match(/struct\s+([^\s\[\]]+)/);
        if (match) {
            const fullName = match[1];
            return fullName.includes('.') ? fullName.split('.').pop()! : fullName;
        }
        return null;
    }


    /**
     * Generate config package
     */
    private generateConfigPackage(graph: ContractGraph, context: GeneratorContext): void {
        this.log('Generating config package...');

        // Generate addresses.py
        this.generateAddressesPy(graph, context);

        // Generate runtime_config.py
        this.generateRuntimeConfigPy(graph, context);

        // Generate config __init__.py
        this.writeFile('config/__init__.py', `"""
Auto-generated config utilities
Generated by contract-sdk-gen
"""

from .addresses import *
from .runtime_config import *
`);
    }

    /**
     * Generate addresses.py
     */
    private generateAddressesPy(graph: ContractGraph, context: GeneratorContext): void {
        const contractNames = Array.from(graph.contracts.keys())
            .filter(name => !graph.contracts.get(name)?.isInterface)
            .sort();

        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        // Convert network names to valid Python identifiers
        const pythonNetworkNames = networkNames.map(name => name.replace('-', '_'));

        const content = `"""
Auto-generated contract addresses by network
Generated by contract-sdk-gen
"""

from typing import Dict, Optional, TypedDict


class NetworkAddresses(TypedDict, total=False):
${contractNames.map(name => `    ${name}: Optional[str]`).join('\n')}


class NetworkContracts(TypedDict):
${pythonNetworkNames.map(network => `    ${network}: NetworkAddresses`).join('\n')}


NETWORK_CONTRACTS: NetworkContracts = {
${pythonNetworkNames.map((pythonNetwork, index) => {
            const originalNetwork = networkNames[index];
            const networkConfig = networks[originalNetwork];
            return `    '${pythonNetwork}': {
${contractNames.map(contractName => {
                const address = networkConfig?.contracts?.[contractName] || '0x0000000000000000000000000000000000000000';
                return `        '${contractName}': '${address}'`;
            }).join(',\n')}
    }`;
        }).join(',\n')}
}


def get_contract_address(network: str, contract: str) -> str:
    """Get contract address by network and contract name"""
    if network not in NETWORK_CONTRACTS:
        raise ValueError(f'Network {network} not found')
    
    address = NETWORK_CONTRACTS[network].get(contract)
    if not address:
        raise ValueError(f'Contract {contract} not found for network {network}')
    
    return address


def get_available_networks() -> list[str]:
    """Get all available networks"""
    return list(NETWORK_CONTRACTS.keys())


def get_network_contracts(network: str) -> NetworkAddresses:
    """Get all contracts for a network"""
    if network not in NETWORK_CONTRACTS:
        raise ValueError(f'Network {network} not found')
    
    return NETWORK_CONTRACTS[network]
`;

        this.writeFile('config/addresses.py', content);
    }

    /**
     * Generate runtime_config.py
     */
    private generateRuntimeConfigPy(_graph: ContractGraph, context: GeneratorContext): void {
        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        const content = `"""
Auto-generated runtime configuration
Generated by contract-sdk-gen
"""

from typing import Dict, TypedDict
from .addresses import NetworkAddresses


class NetworkConfig(TypedDict):
    chain_id: int
    name: str
    rpc: str
    explorer: str
    contracts: NetworkAddresses


class RuntimeConfig(TypedDict):
    networks: Dict[str, NetworkConfig]
    version: str


runtime_config: RuntimeConfig = {
    'networks': {
${networkNames.map(network => {
            const networkConfig = networks[network];
            return `        '${network}': {
            'chain_id': ${networkConfig?.chainId || 0},
            'name': '${networkConfig?.name || network}',
            'rpc': '${networkConfig?.rpc || 'undefined'}',
            'explorer': '${networkConfig?.explorer || 'undefined'}',
            'contracts': {
${Object.entries(networkConfig?.contracts || {}).map(([contract, address]) =>
                `                '${contract}': '${address}'`
            ).join(',\n')}
            }
        }`;
        }).join(',\n')}
    },
    'version': '${context.fullConfig?.generation?.targets?.[0]?.options?.packageVersion || '1.0.0'}'
}
`;

        this.writeFile('config/runtime_config.py', content);
    }

    /**
     * Generate pyproject.toml
     */
    private generatePyprojectToml(): void {
        const content = `[tool.poetry]
name = "${this.options.packageName || 'contract-sdk'}"
version = "${this.options.packageVersion || '1.0.0'}"
description = "Auto-generated SDK for smart contracts"
authors = []

[tool.poetry.dependencies]
python = "^3.9"
web3 = "^6.0.0"
pydantic = "^2.0.0"

[tool.poetry.dev-dependencies]
pytest = "^7.0.0"
black = "^23.0.0"
ruff = "^0.1.0"
mypy = "^1.0.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
`;
        this.writeFile('pyproject.toml', content);
    }

    /**
     * Generate __init__.py
     */
    private generateInit(graph: ContractGraph): void {
        // Generate package __init__.py files
        this.generateContractsInit(graph);
        this.generateInterfacesInit(graph);

        // Generate main __init__.py
        const contractImports = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => !contract.isInterface)
            .map(([name, _contract]) => {
                const moduleName = this.toSnakeCase(name);
                return `from .contracts.${moduleName} import ${name}`;
            })
            .join('\n');

        const interfaceImports = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => contract.isInterface)
            .map(([name, _contract]) => {
                const moduleName = this.toSnakeCase(name);
                return `from .interfaces.${moduleName} import ${name}`;
            })
            .join('\n');

        const content = `"""Contract SDK"""

# Contract classes
${contractImports}

# Interface classes
${interfaceImports}

# Types
from .types import *

# Config utilities
from .config import *
`;

        this.writeFile('__init__.py', content);
    }

    /**
     * Generate contracts __init__.py
     */
    private generateContractsInit(graph: ContractGraph): void {
        const contractNames = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => !contract.isInterface)
            .map(([name, _contract]) => name);

        const imports = contractNames
            .map(name => {
                const moduleName = this.toSnakeCase(name);
                return `from .${moduleName} import ${name}`;
            })
            .join('\n');

        const content = `"""Contract implementations"""

${imports}
`;

        this.writeFile('contracts/__init__.py', content);
    }

    /**
     * Generate interfaces __init__.py
     */
    private generateInterfacesInit(graph: ContractGraph): void {
        const interfaceNames = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => contract.isInterface)
            .map(([name, _contract]) => name);

        const imports = interfaceNames
            .map(name => {
                const moduleName = this.toSnakeCase(name);
                return `from .${moduleName} import ${name}`;
            })
            .join('\n');

        const content = `"""Contract interfaces"""

${imports}
`;

        this.writeFile('interfaces/__init__.py', content);
    }

    /**
     * Generate signature files for EIP-712 typed data
     */
    private generateSignatures(signatureItems: SignatureItem[], graph: ContractGraph): void {
        this.log('Generating EIP-712 signature utilities...');

        // Generate domain utilities
        this.generateDomainFile();

        // Generate signature files for each item
        for (const item of signatureItems) {
            this.generateSignatureFile(item, graph);
        }

        // Generate signatures __init__.py
        this.generateSignaturesInit(signatureItems);
    }

    /**
     * Generate domain utilities
     */
    private generateDomainFile(): void {
        const content = `"""EIP-712 Domain utilities
Generated by contract-sdk-gen
"""

from typing import Optional
from pydantic import BaseModel, Field


class Eip712Domain(BaseModel):
    """EIP-712 domain configuration"""
    
    name: str = Field(..., description="Domain name")
    version: str = Field(..., description="Domain version")
    chain_id: Optional[int] = Field(None, description="Chain ID")
    verifying_contract: Optional[str] = Field(None, description="Verifying contract address")


def build_domain(domain: Eip712Domain) -> dict:
    """Build domain dictionary for EIP-712"""
    result = {
        "name": domain.name,
        "version": domain.version,
    }
    
    if domain.chain_id is not None:
        result["chainId"] = domain.chain_id
    
    if domain.verifying_contract is not None:
        result["verifyingContract"] = domain.verifying_contract
    
    return result
`;

        this.writeFile('signatures/domain.py', content);
    }

    /**
     * Generate signature file for a specific signature item
     */
    private generateSignatureFile(item: SignatureItem, graph: ContractGraph): void {
        const fileName = this.toSnakeCase(item.primaryType);

        // Find the contract in the graph
        const contract = graph.contracts.get(item.contract);
        if (!contract) {
            this.logError(`Contract ${item.contract} not found for signature ${item.primaryType}`);
            return;
        }

        // Extract types from contract artifacts
        const types = this.extractTypesFromContract(contract, item.primaryType);
        if (!types) {
            this.logError(`Could not extract types for ${item.primaryType} from contract ${item.contract}`);
            return;
        }

        // Generate Pydantic models for all types
        const typeModels = this.generateTypeModels(types);

        // Generate hash function
        const hashFunction = this.generateHashFunction(item, types);

        // Generate sign function
        const signFunction = this.generateSignFunction(item, types);

        const content = `"""EIP-712 signature utilities for ${item.primaryType}
Generated by contract-sdk-gen
"""

from typing import Dict, List, Any, Optional, TYPE_CHECKING
from pydantic import BaseModel, Field
from eth_account.messages import encode_typed_data
from eth_account import Account
from .domain import Eip712Domain, build_domain

if TYPE_CHECKING:
    pass

${typeModels}

def build_${this.toSnakeCase(item.primaryType)}_typed_data(
    domain: Eip712Domain,
    message: ${this.toPascalCase(item.primaryType)}
) -> Dict[str, Any]:
    """Build typed data for ${item.primaryType}"""
    return {
        "domain": build_domain(domain),
        "types": {
${Object.keys(types).map(typeName =>
            `            "${typeName}": [${types[typeName].map(field =>
                `{"name": "${field.name}", "type": "${field.type}"}`
            ).join(', ')}]`
        ).join(',\n')}
        },
        "primaryType": "${item.primaryType}",
        "message": message.model_dump() if hasattr(message, 'model_dump') else message,
    }


${hashFunction}

${signFunction}
`;

        this.writeFile(`signatures/${fileName}.py`, content);
    }

    /**
     * Generate Pydantic models for EIP-712 types
     */
    private generateTypeModels(types: Record<string, Array<{ name: string; type: string }>>): string {
        const models: string[] = [];
        const allTypeNames = Object.keys(types);

        for (const [typeName, fields] of Object.entries(types)) {
            const modelName = this.toPascalCase(typeName);
            const fieldDefinitions = fields.map(field => {
                const fieldName = field.name;
                const fieldType = this.mapSolidityTypeToPythonForSignature(field.type);

                // Use string literal for forward references
                const pythonType = allTypeNames.includes(field.type) ? `'${fieldType}'` : fieldType;

                return `    ${fieldName}: ${pythonType} = Field(..., description="${field.name}")`;
            }).join('\n');

            models.push(`class ${modelName}(BaseModel):
    """${typeName} model"""
    
${fieldDefinitions}
`);
        }

        return models.join('\n\n');
    }

    /**
     * Generate hash function
     */
    private generateHashFunction(item: SignatureItem, _types: Record<string, Array<{ name: string; type: string }>>): string {
        const functionName = `hash_${this.toSnakeCase(item.primaryType)}`;

        return `def ${functionName}(typed_data: Dict[str, Any]) -> str:
    """Hash typed data for ${item.primaryType}"""
    encoded = encode_typed_data(typed_data)
    return encoded.body.hex()
`;
    }

    /**
     * Generate sign function
     */
    private generateSignFunction(item: SignatureItem, _types: Record<string, Array<{ name: string; type: string }>>): string {
        const functionName = `sign_${this.toSnakeCase(item.primaryType)}`;

        return `def ${functionName}(
    private_key: str,
    domain: Eip712Domain,
    message: ${this.toPascalCase(item.primaryType)}
) -> str:
    """Sign typed data for ${item.primaryType}"""
    typed_data = build_${this.toSnakeCase(item.primaryType)}_typed_data(domain, message)
    account = Account.from_key(private_key)
    signed_message = account.sign_message(encode_typed_data(typed_data))
    return signed_message.signature.hex()
`;
    }

    /**
     * Generate signatures __init__.py
     */
    private generateSignaturesInit(signatureItems: SignatureItem[]): void {
        const exports = signatureItems.map(item => {
            const fileName = this.toSnakeCase(item.primaryType);
            return `from .${fileName} import *`;
        }).join('\n');

        const content = `"""EIP-712 signature utilities
Generated by contract-sdk-gen
"""

from .domain import *

${exports}
`;

        this.writeFile('signatures/__init__.py', content);
    }

    /**
     * Convert string to PascalCase
     */
    private toPascalCase(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    /**
     * Map Solidity type to Python type for signature generation
     */
    private mapSolidityTypeToPythonForSignature(solidityType: string): string {
        // Handle arrays
        if (solidityType.endsWith('[]')) {
            const baseType = solidityType.slice(0, -2);
            return `List[${this.mapSolidityTypeToPythonForSignature(baseType)}]`;
        }

        // Handle basic types
        switch (solidityType) {
            case 'bool':
                return 'bool';
            case 'uint8':
            case 'uint16':
            case 'uint32':
            case 'uint64':
            case 'uint128':
            case 'uint256':
            case 'int8':
            case 'int16':
            case 'int32':
            case 'int64':
            case 'int128':
            case 'int256':
                return 'int';
            case 'address':
                return 'str';
            case 'bytes':
            case 'bytes32':
                return 'str';
            case 'string':
                return 'str';
            default:
                // Assume it's a custom type (struct)
                return this.toPascalCase(solidityType);
        }
    }

    /**
     * Extract EIP-712 types from contract artifacts
     */
    private extractTypesFromContract(contract: ContractModel, primaryType: string): Record<string, Array<{ name: string; type: string }>> | null {
        // Look for the TYPED_DATA_SIGNATURE_TYPEHASH constant in the contract
        // This contains the keccak256 hash of the type definition
        const typeHashConstant = contract.abi.find((item: any) =>
            item.name === 'TYPED_DATA_SIGNATURE_TYPEHASH' &&
            item.type === 'function' &&
            item.stateMutability === 'view'
        );

        if (!typeHashConstant) {
            return null;
        }

        // For now, we'll need to parse the type definition from the contract source
        // This is a simplified approach - in a real implementation, you'd want to
        // parse the contract source code or have the types defined elsewhere

        // Based on the contracts.yaml, we know the types for BidAuthorization and ReputationRecord
        if (primaryType === 'BidAuthorization') {
            return {
                BidAuthorization: [
                    { name: 'bid', type: 'Bid' },
                    { name: 'issuedAt', type: 'uint64' },
                    { name: 'expiresAt', type: 'uint64' }
                ],
                Bid: [
                    { name: 'offererId', type: 'bytes32' },
                    { name: 'requirements', type: 'Requirements' },
                    { name: 'payment', type: 'Payment' },
                    { name: 'timing', type: 'Timing' },
                    { name: 'status', type: 'Status' }
                ],
                Requirements: [
                    { name: 'requireVerified', type: 'bool' },
                    { name: 'allowedAttestationRoots', type: 'bytes32' },
                    { name: 'allowedAgentsRoot', type: 'bytes32' },
                    { name: 'minTrustScore', type: 'uint256' }
                ],
                Payment: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' },
                    { name: 'authorizationSig', type: 'bytes' }
                ],
                Timing: [
                    { name: 'startTime', type: 'uint256' },
                    { name: 'endTime', type: 'uint256' },
                    { name: 'nonce', type: 'bytes32' },
                    { name: 'signature', type: 'bytes' }
                ],
                Status: [
                    { name: 'requestHash', type: 'bytes32' },
                    { name: 'responseHash', type: 'bytes32' },
                    { name: 'completedBy', type: 'bytes32' },
                    { name: 'state', type: 'uint8' },
                    { name: 'refundPercent', type: 'uint8' }
                ]
            };
        } else if (primaryType === 'ReputationRecord') {
            return {
                ReputationRecord: [
                    { name: 'bidId', type: 'bytes32' },
                    { name: 'score', type: 'uint8' },
                    { name: 'comment', type: 'string' },
                    { name: 'tags', type: 'Tag[]' },
                    { name: 'nonce', type: 'bytes32' }
                ],
                Tag: [
                    { name: 'value', type: 'uint8' }
                ]
            };
        }

        return null;
    }
}

