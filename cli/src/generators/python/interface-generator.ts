/**
 * Python interface generation logic
 */

import { ContractModel, Parameter, ContractGraph } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class InterfaceGenerator {
    private outDir: string;
    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate interface module
     */
    async generateInterface(interface_: ContractModel): Promise<void> {
        const moduleName = PythonUtils.toSnakeCase(interface_.name);

        // Generate interface class file
        const content = this.renderInterfaceTemplate(interface_);
        this.writeFile(`interfaces/${moduleName}/${moduleName}.py`, content);

        // Generate separate ABI file
        this.generateAbiFile(interface_, moduleName);

        // Generate __init__.py
        this.writeFile(`interfaces/${moduleName}/__init__.py`,
            `from .${moduleName} import ${interface_.name}\nfrom .abi import ABI\n`);
    }

    /**
     * Generate separate ABI file
     */
    private generateAbiFile(interface_: ContractModel, moduleName: string): void {
        // Convert JavaScript boolean values to Python boolean values
        const abiString = JSON.stringify(interface_.abi, null, 4)
            .replace(/\btrue\b/g, 'True')
            .replace(/\bfalse\b/g, 'False');

        const content = `"""
Auto-generated ABI for ${interface_.name}
Generated by contract-sdk-gen
"""

# Interface ABI
ABI = ${abiString}
`;
        this.writeFile(`interfaces/${moduleName}/abi.py`, content);
    }

    /**
     * Render interface template
     */
    private renderInterfaceTemplate(interface_: ContractModel): string {
        return `"""
Auto-generated interface wrapper for ${interface_.name}
Generated by contract-sdk-gen
"""

from typing import Optional
from web3 import Web3
from web3.contract import Contract
from .abi import ABI

class ${interface_.name}:
    """${interface_.natspec?.notice || interface_.name + ' interface'}"""
    
    def __init__(self, web3: Web3, address: str):
        self.web3 = web3
        self.address = Web3.to_checksum_address(address)
        self.contract = web3.eth.contract(address=self.address, abi=ABI)

${interface_.functions.map(func => this.renderPythonMethod(func)).join('\n\n')}
`;
    }

    /**
     * Render Python method
     */
    private renderPythonMethod(func: any): string {
        const methodName = PythonUtils.toSnakeCase(func.name);

        // Generate unique parameter names
        const paramNames: string[] = [];
        const params = func.inputs.map((input: Parameter, index: number) => {
            let paramName: string;
            if (input.name) {
                paramName = PythonUtils.toSnakeCase(input.name);
            } else {
                paramName = `arg${index}`;
            }
            const safeParamName = PythonUtils.makePythonSafeParamName(paramName);
            paramNames.push(safeParamName);
            return `${safeParamName}: ${PythonUtils.mapSolidityTypeToPython(input)}`;
        }).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
        const callParams = paramNames.join(', ');

        return `    def ${methodName}(self${params ? ', ' + params : ''}):
        """${func.name}"""
        ${isReadOnly
                ? `return self.contract.functions.${func.name}(${callParams}).call()`
                : `tx = self.contract.functions.${func.name}(${callParams}).transact()
        return tx`
            }`;
    }

    /**
     * Generate interfaces package __init__.py
     */
    generatePackageInit(graph: ContractGraph): void {
        const interfaceNames = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => contract.isInterface)
            .map(([name, _contract]) => name);

        const imports = interfaceNames
            .map(name => {
                const moduleName = PythonUtils.toSnakeCase(name as string);
                return `from .${moduleName} import ${name}`;
            })
            .join('\n');

        const content = `"""Contract interfaces"""

${imports}
`;

        this.writeFile('interfaces/__init__.py', content);
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
