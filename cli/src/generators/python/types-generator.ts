/**
 * Python types generation logic
 */

import { ContractGraph } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class TypesGenerator {
    private outDir: string;
    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate centralized types package
     */
    async generateTypes(graph: ContractGraph): Promise<void> {
        this.log('Generating centralized types...');

        // Collect all structs from all contracts and deduplicate
        const allStructs = new Map<string, any>();

        for (const [_contractName, contract] of graph.contracts.entries()) {
            for (const struct of contract.structs) {
                if (!allStructs.has(struct.name)) {
                    allStructs.set(struct.name, struct);
                }
            }
        }

        if (allStructs.size === 0) {
            // Create empty types package
            this.writeFile('types/__init__.py', `"""
Auto-generated types
Generated by contract-sdk-gen
"""

# No custom types
`);
            return;
        }

        // Generate types content
        const typesContent = `"""
Auto-generated types
Generated by contract-sdk-gen
"""

from pydantic import BaseModel
from typing import List, Optional

${Array.from(allStructs.values()).map(struct => `
class ${struct.name}(BaseModel):
    """${struct.name} struct"""
${struct.fields.map((field: any) => `    ${PythonUtils.toSnakeCase(field.name)}: ${PythonUtils.mapSolidityTypeToPython(field)}`).join('\n')}
`).join('\n')}
`;

        this.writeFile('types/__init__.py', typesContent);
    }

    /**
     * Log helper
     */
    private log(message: string): void {
        console.log(`  ${message}`);
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
