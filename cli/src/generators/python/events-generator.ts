/**
 * Python events generation logic
 */

import { ContractModel, EventModel } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class EventsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate events file for a contract
     */
    async generateEvents(contract: ContractModel): Promise<void> {
        if (contract.events.length === 0) {
            return; // Skip if no events
        }

        const moduleName = PythonUtils.toSnakeCase(contract.name);
        const content = this.renderEventsTemplate(contract);
        this.writeFile(`contracts/${moduleName}/events.py`, content);
    }

    /**
     * Render events template
     */
    private renderEventsTemplate(contract: ContractModel): string {
        const contractName = contract.name;

        // Generate event signatures
        const eventSignatures = contract.events.map(event => {
            const canonicalSig = EventModel.getCanonicalSignature(event);
            const constantName = `${event.name.toUpperCase()}_EVENT_SIGNATURE`;
            return `${constantName} = Web3.keccak(text="${canonicalSig}").hex()`;
        }).join('\n');

        // Generate decode functions
        const decodeFunctions = contract.events.map(event => {
            const functionName = PythonUtils.toSnakeCase(`decode_${event.name}_event`);
            return `def ${functionName}(log):
    """Decode ${event.name} event from log"""
    event_abi = next(e for e in ABI if e['type'] == 'event' and e['name'] == '${event.name}')
    contract = web3.eth.contract(abi=[event_abi])
    decoded = contract.events.${event.name}().process_log(log)
    return decoded['args']`;
        }).join('\n\n');

        // Generate helper functions
        const helperFunctions = contract.events.map(event => {
            const constantName = `${event.name.toUpperCase()}_EVENT_SIGNATURE`;
            const hasFunctionName = PythonUtils.toSnakeCase(`has_${event.name}_event`);
            const findFunctionName = PythonUtils.toSnakeCase(`find_${event.name}_events`);
            const decodeFunctionName = PythonUtils.toSnakeCase(`decode_${event.name}_event`);

            return `def ${hasFunctionName}(logs):
    """Check if logs contain ${event.name} event"""
    return any(log.get('topics', [None])[0] == ${constantName} for log in logs)

def ${findFunctionName}(logs):
    """Find all ${event.name} events in logs"""
    return [${decodeFunctionName}(log) for log in logs if ${hasFunctionName}([log])]`;
        }).join('\n\n');

        // Generate filter builders
        const filterBuilders = contract.events.map(event => {
            const indexedParams = event.inputs.filter(p => p.indexed);
            const functionName = PythonUtils.toSnakeCase(`create_${event.name}_event_filter`);

            if (indexedParams.length === 0) {
                return `def ${functionName}(from_block=None, to_block=None):
    """Create filter for ${event.name} events"""
    return {
        'address': None,  # Will be set by caller
        'topics': [${event.name.toUpperCase()}_EVENT_SIGNATURE],
        'fromBlock': from_block,
        'toBlock': to_block,
    }`;
            } else {
                const paramNames = indexedParams.map(p => PythonUtils.toSnakeCase(p.name)).join(', ');

                return `def ${functionName}(from_block=None, to_block=None, ${paramNames}=None):
    """Create filter for ${event.name} events"""
    topics = [${event.name.toUpperCase()}_EVENT_SIGNATURE]
    ${indexedParams.map(p =>
                    `if ${PythonUtils.toSnakeCase(p.name)} is not None:
        topics.append(web3.to_hex(${PythonUtils.toSnakeCase(p.name)}))`
                ).join('\n    ')}
    
    return {
        'address': None,  # Will be set by caller
        'topics': topics,
        'fromBlock': from_block,
        'toBlock': to_block,
    }`;
            }
        }).join('\n\n');

        return `"""
Auto-generated events for ${contractName}
Generated by contract-sdk-gen
"""

from typing import List, Dict, Any, Optional
from web3 import Web3
from .abi import ABI

# Event signatures
${eventSignatures}

# Decode functions
${decodeFunctions}

# Helper functions
${helperFunctions}

# Filter builders
${filterBuilders}
`;
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
