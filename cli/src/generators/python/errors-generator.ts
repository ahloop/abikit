/**
 * Python errors generation logic
 */

import { ContractModel, ErrorModel } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class ErrorsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate errors file for a contract
     */
    async generateErrors(contract: ContractModel): Promise<void> {
        if (contract.errors.length === 0) {
            return; // Skip if no errors
        }

        const moduleName = PythonUtils.toSnakeCase(contract.name);
        const content = this.renderErrorsTemplate(contract);
        this.writeFile(`contracts/${moduleName}/errors.py`, content);
    }

    /**
     * Generate centralized error registry
     */
    async generateCentralizedErrors(contracts: ContractModel[]): Promise<void> {
        const contractsWithErrors = contracts.filter(contract => contract.errors.length > 0);

        if (contractsWithErrors.length === 0) {
            return; // Skip if no contracts have errors
        }

        const content = this.renderCentralizedErrorsTemplate(contractsWithErrors);
        this.writeFile(`errors/__init__.py`, content);
    }

    /**
     * Render per-contract errors template
     */
    private renderErrorsTemplate(contract: ContractModel): string {
        const contractName = contract.name;

        // Generate error selectors
        const errorSelectors = contract.errors.map(error => {
            const canonicalSig = ErrorModel.getCanonicalSignature(error);
            const constantName = `${error.name.toUpperCase()}_ERROR_SELECTOR`;
            return `${constantName} = Web3.keccak(text="${canonicalSig}")[:4].hex()`;
        }).join('\n');

        // Generate decode functions
        const decodeFunctions = contract.errors.map(error => {
            const functionName = PythonUtils.toSnakeCase(`decode_${error.name}_error`);
            const paramNames = error.inputs.map(input => PythonUtils.toSnakeCase(input.name)).join(', ');

            return `def ${functionName}(data: str):
    """Decode ${error.name} error from hex data"""
    # Remove 0x prefix and 4-byte selector
    data_bytes = bytes.fromhex(data[2:10])  # Skip selector
    
    # Use web3.py's contract error decoding
    error_abi = next(e for e in ABI if e['type'] == 'error' and e['name'] == '${error.name}')
    contract = web3.eth.contract(abi=[error_abi])
    
    try:
        decoded = contract.decode_function_input(data)
        return {
            ${paramNames ? paramNames.split(', ').map(name => `"${name}": decoded[1].get("${name}")`).join(',\n            ') : ''}
        }
    except Exception as e:
        # Fallback to manual decoding if contract method fails
        return {"error": f"Failed to decode: {str(e)}"}`;
        }).join('\n\n');

        return `"""
Auto-generated errors for ${contractName}
Generated by contract-sdk-gen
"""

from typing import Dict, Any
from web3 import Web3
from .abi import ABI

# Error selectors
${errorSelectors}

# Decode functions
${decodeFunctions}
`;
    }

    /**
     * Render centralized errors template
     */
    private renderCentralizedErrorsTemplate(contracts: ContractModel[]): string {
        // Generate imports for all contract errors
        const imports = contracts.map(contract => {
            const moduleName = PythonUtils.toSnakeCase(contract.name);
            return `from ..contracts.${moduleName} import errors as ${moduleName}_errors`;
        }).join('\n');

        // Generate error registry population
        const errorRegistryPopulation = contracts.map(contract => {
            const moduleName = PythonUtils.toSnakeCase(contract.name);
            return `# Populate from ${contract.name}
for attr in dir(${moduleName}_errors):
    if attr.endswith('_ERROR_SELECTOR'):
        ERROR_REGISTRY[getattr(${moduleName}_errors, attr)] = attr
    elif attr.startswith('decode_') and attr.endswith('_error'):
        ERROR_DECODERS[attr] = getattr(${moduleName}_errors, attr)`;
        }).join('\n');

        return `"""
Auto-generated centralized error registry
Generated by contract-sdk-gen
"""

from typing import Dict, Any, Optional

# Import all contract errors
${imports}

# Combined error registry
ERROR_REGISTRY: Dict[str, str] = {}
ERROR_DECODERS: Dict[str, callable] = {}

# Populate registry
${errorRegistryPopulation}

def decode_contract_error(error_data: str) -> Optional[Dict[str, Any]]:
    """Decode contract error from hex data"""
    selector = error_data[:10] if error_data.startswith('0x') else '0x' + error_data[:8]
    
    if selector not in ERROR_REGISTRY:
        return None
    
    error_name = ERROR_REGISTRY[selector]
    decoder_name = f"decode_{error_name.replace('_ERROR_SELECTOR', '_error').lower()}"
    
    if decoder_name not in ERROR_DECODERS:
        return None
    
    try:
        decoder = ERROR_DECODERS[decoder_name]
        args = decoder(error_data)
        return {
            'name': error_name.replace('_ERROR_SELECTOR', ''),
            'selector': selector,
            'args': args
        }
    except Exception as e:
        return {
            'name': error_name.replace('_ERROR_SELECTOR', ''),
            'selector': selector,
            'error': f"Failed to decode: {str(e)}"
        }

def get_error_selector(error_name: str) -> Optional[str]:
    """Get error selector by name"""
    selector_key = f"{error_name.upper()}_ERROR_SELECTOR"
    for selector, name in ERROR_REGISTRY.items():
        if name == selector_key:
            return selector
    return None

def get_error_name(selector: str) -> Optional[str]:
    """Get error name by selector"""
    if selector in ERROR_REGISTRY:
        return ERROR_REGISTRY[selector].replace('_ERROR_SELECTOR', '')
    return None

def is_known_error(selector: str) -> bool:
    """Check if error selector is known"""
    return selector in ERROR_REGISTRY

# Export all error selectors and decoders for direct access
from ..contracts import *
`;
    }


    /**
     * Simple keccak256 implementation for generation time
     * In a real implementation, this would use a proper keccak256 library
     */

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
