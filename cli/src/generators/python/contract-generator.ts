/**
 * Python contract generation logic
 */

import { ContractModel, Parameter, ContractGraph } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class ContractGenerator {
    private outDir: string;
    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate contract module
     */
    async generateContract(contract: ContractModel): Promise<void> {
        const moduleName = PythonUtils.toSnakeCase(contract.name);

        // Generate contract class file
        const content = this.renderContractTemplate(contract);
        this.writeFile(`contracts/${moduleName}/${moduleName}.py`, content);

        // Generate separate ABI file
        this.generateAbiFile(contract, moduleName);

        // Generate __init__.py
        const hasEvents = contract.events.length > 0;
        const hasSelectors = contract.functions.some(func =>
            ['pure', 'view', 'nonpayable', 'payable'].includes(func.stateMutability)
        );
        const hasErrors = contract.errors.length > 0;

        let initContent = `from .${moduleName} import ${contract.name}\nfrom .abi import ABI\n`;

        if (hasEvents) {
            initContent += `from .events import *\n`;
        }
        if (hasSelectors) {
            initContent += `from .selectors import *\n`;
        }
        if (hasErrors) {
            initContent += `from .errors import *\n`;
        }

        this.writeFile(`contracts/${moduleName}/__init__.py`, initContent);
    }

    /**
     * Generate separate ABI file
     */
    private generateAbiFile(contract: ContractModel, moduleName: string): void {
        // Convert JavaScript boolean values to Python boolean values
        const abiString = JSON.stringify(contract.abi, null, 4)
            .replace(/\btrue\b/g, 'True')
            .replace(/\bfalse\b/g, 'False');

        const content = `"""
Auto-generated ABI for ${contract.name}
Generated by contract-sdk-gen
"""

# Contract ABI
ABI = ${abiString}
`;
        this.writeFile(`contracts/${moduleName}/abi.py`, content);
    }

    /**
     * Render contract template
     */
    private renderContractTemplate(contract: ContractModel): string {
        return `"""
Auto-generated contract wrapper for ${contract.name}
Generated by contract-sdk-gen
"""

from typing import Optional
from web3 import Web3
from web3.contract import Contract
from .abi import ABI

class ${contract.name}:
    """${contract.natspec?.notice || contract.name + ' contract'}"""
    
    def __init__(self, web3: Web3, address: str):
        self.web3 = web3
        self.address = Web3.to_checksum_address(address)
        self.contract = web3.eth.contract(address=self.address, abi=ABI)

${contract.functions.map(func => this.renderPythonMethod(func)).join('\n\n')}
`;
    }

    /**
     * Render Python method
     */
    private renderPythonMethod(func: any): string {
        const methodName = PythonUtils.toSnakeCase(func.name);

        // Generate unique parameter names
        const paramNames: string[] = [];
        const params = func.inputs.map((input: Parameter, index: number) => {
            let paramName: string;
            if (input.name) {
                paramName = PythonUtils.toSnakeCase(input.name);
            } else {
                paramName = `arg${index}`;
            }
            const safeParamName = PythonUtils.makePythonSafeParamName(paramName);
            paramNames.push(safeParamName);
            return `${safeParamName}: ${PythonUtils.mapSolidityTypeToPython(input)}`;
        }).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
        const callParams = paramNames.join(', ');

        return `    def ${methodName}(self${params ? ', ' + params : ''}):
        """${func.name}"""
        ${isReadOnly
                ? `return self.contract.functions.${func.name}(${callParams}).call()`
                : `tx = self.contract.functions.${func.name}(${callParams}).transact()
        return tx`
            }`;
    }

    /**
     * Generate contracts package __init__.py
     */
    generatePackageInit(graph: ContractGraph): void {
        const contractNames = Array.from(graph.contracts.entries())
            .filter(([_name, contract]) => !contract.isInterface)
            .map(([name, _contract]) => name);

        const imports = contractNames
            .map(name => {
                const moduleName = PythonUtils.toSnakeCase(name as string);
                return `from .${moduleName} import ${name}`;
            })
            .join('\n');

        const content = `"""Contract implementations"""

${imports}
`;

        this.writeFile('contracts/__init__.py', content);
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
