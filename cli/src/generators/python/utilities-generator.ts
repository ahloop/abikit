/**
 * Python utilities generation logic
 */

import { PythonTargetOptions } from '../../types/config';
import { BaseGenerator } from '../base';

export class UtilitiesGenerator extends BaseGenerator {
    protected options: PythonTargetOptions;

    constructor(outDir: string, options: PythonTargetOptions) {
        super(outDir, options);
        this.options = options;
    }

    getName(): string {
        return 'Python Utilities Generator';
    }

    async generate(): Promise<void> {
        // This method is required by BaseGenerator but not used
        // We call generateUtilities() directly instead
    }

    validateOptions(): void {
        // No validation needed for utilities generation
    }

    /**
     * Generate all utility files
     */
    generateUtilities(): void {
        this.generateBlockchainUtilities();
        this.generateUtilsIndex();
    }

    /**
     * Generate generic blockchain utilities
     */
    private generateBlockchainUtilities(): void {
        const content = `"""
Generic blockchain utilities for web3.py
Auto-generated by ABIKIT
"""

from typing import Optional
from web3 import Web3
from web3.types import Wei, Address, HexStr, BlockNumber, TxReceipt
from eth_typing import HexStr as EthHexStr


def to_wei(amount: str | int | float) -> Wei:
    """Convert ETH to Wei"""
    return Web3.to_wei(amount, 'ether')


def from_wei(amount: Wei) -> str:
    """Convert Wei to ETH"""
    return Web3.from_wei(amount, 'ether')


def to_hex(value: int) -> HexStr:
    """Convert integer to hex string"""
    return Web3.to_hex(value)


def is_address(address: str) -> bool:
    """Check if string is a valid Ethereum address"""
    return Web3.is_address(address)


def to_checksum_address(address: str) -> Address:
    """Get checksummed version of address"""
    return Web3.to_checksum_address(address)


def to_bytes32(text: str) -> HexStr:
    """Convert string to bytes32 format"""
    return Web3.to_hex(Web3.to_bytes(text=text, hexstr=None, type='bytes32'))


def from_bytes32(hex_str: HexStr) -> str:
    """Convert bytes32 to string"""
    return Web3.to_text(hexstr=hex_str)


def is_hex(value: str) -> bool:
    """Check if value is a valid hex string"""
    return Web3.is_hex(value)


def pad_hex(hex_str: str, length: int) -> HexStr:
    """Pad hex string to specific length"""
    clean_hex = hex_str[2:] if hex_str.startswith('0x') else hex_str
    padded = clean_hex.zfill(length)
    return f"0x{padded}"


def slice_hex(hex_str: str, start: int, end: Optional[int] = None) -> HexStr:
    """Slice hex string to specific length"""
    clean_hex = hex_str[2:] if hex_str.startswith('0x') else hex_str
    if end is None:
        sliced = clean_hex[start * 2:]
    else:
        sliced = clean_hex[start * 2:end * 2]
    return f"0x{sliced}"


def wait_for_transaction_receipt(
    web3: Web3,
    tx_hash: HexStr,
    confirmations: int = 1
) -> TxReceipt:
    """Wait for transaction to be mined"""
    return web3.eth.wait_for_transaction_receipt(tx_hash, confirmations)


def get_current_block_number(web3: Web3) -> BlockNumber:
    """Get current block number"""
    return web3.eth.block_number


def get_gas_price(web3: Web3) -> Wei:
    """Get current gas price"""
    return web3.eth.gas_price


def estimate_gas(
    web3: Web3,
    transaction: dict
) -> Wei:
    """Estimate gas for transaction"""
    return web3.eth.estimate_gas(transaction)


def get_balance(web3: Web3, address: Address) -> Wei:
    """Get balance of address"""
    return web3.eth.get_balance(address)


def get_transaction_count(web3: Web3, address: Address) -> int:
    """Get nonce of address"""
    return web3.eth.get_transaction_count(address)


def contract_exists(web3: Web3, address: Address) -> bool:
    """Check if a contract exists at the given address"""
    code = web3.eth.get_code(address)
    return code != b''


def create_web3_from_rpc(rpc_url: str) -> Web3:
    """Create Web3 instance from RPC URL"""
    return Web3(Web3.HTTPProvider(rpc_url))


def get_block_info(web3: Web3, block_number: BlockNumber) -> dict:
    """Get block information"""
    block = web3.eth.get_block(block_number)
    return {
        'number': block.number,
        'timestamp': block.timestamp,
        'hash': block.hash,
        'parent_hash': block.parentHash,
        'gas_limit': block.gasLimit,
        'gas_used': block.gasUsed
    }


def get_block_timestamp(web3: Web3, block_number: BlockNumber) -> int:
    """Get block timestamp"""
    block = web3.eth.get_block(block_number)
    return block.timestamp


def format_block_timestamp(timestamp: int) -> str:
    """Format block timestamp to ISO string"""
    from datetime import datetime
    return datetime.fromtimestamp(timestamp).isoformat()


def get_latest_block_number(web3: Web3) -> BlockNumber:
    """Get latest block number"""
    return web3.eth.block_number


def wait_for_blocks(web3: Web3, block_count: int) -> None:
    """Wait for specific number of blocks"""
    import time
    
    start_block = web3.eth.block_number
    target_block = start_block + block_count
    
    while True:
        current_block = web3.eth.block_number
        if current_block >= target_block:
            break
        time.sleep(1)  # Wait 1 second before checking again
`;

        this.writeFile('utils/blockchain.py', content);
    }

    /**
     * Generate utils index file
     */
    private generateUtilsIndex(): void {
        const content = `"""
Utilities index
Auto-generated by ABIKIT
"""

from .blockchain import *
`;

        this.writeFile('utils/__init__.py', content);
    }
}
