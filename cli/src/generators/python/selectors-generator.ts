/**
 * Python selectors generation logic
 */

import { ContractModel, FunctionModel } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { PythonUtils } from './utils';

export class SelectorsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate selectors file for a contract
     */
    async generateSelectors(contract: ContractModel): Promise<void> {
        // Only generate selectors for functions that should have them (public/external)
        const functionsWithSelectors = contract.functions.filter(func =>
            FunctionModel.shouldGenerateSelector(func)
        );

        if (functionsWithSelectors.length === 0) {
            return; // Skip if no functions need selectors
        }

        const moduleName = PythonUtils.toSnakeCase(contract.name);
        const content = this.renderSelectorsTemplate(contract, functionsWithSelectors);
        this.writeFile(`contracts/${moduleName}/selectors.py`, content);
    }

    /**
     * Render selectors template
     */
    private renderSelectorsTemplate(contract: ContractModel, functions: FunctionModel[]): string {
        const contractName = contract.name;

        // Generate function selectors
        const functionSelectors = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const constantName = `${func.name.toUpperCase()}_FUNCTION_SELECTOR`;
            return `${constantName} = Web3.keccak(text="${canonicalSig}")[:4].hex()`;
        }).join('\n');

        // Generate selector to function name mapping
        const selectorMapping = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const selector = this.computeFunctionSelector(canonicalSig);
            return `    "${selector}": "${func.name}",`;
        }).join('\n');

        // Generate reverse mapping (function name to selector)
        const functionMapping = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const selector = this.computeFunctionSelector(canonicalSig);
            return `    "${func.name}": "${selector}",`;
        }).join('\n');

        return `"""
Auto-generated selectors for ${contractName}
Generated by contract-sdk-gen
"""

from typing import Optional
from web3 import Web3

# Function selectors (first 4 bytes of keccak256 of function signature)
${functionSelectors}

# Selector to function name mapping
FUNCTION_SELECTORS = {
${selectorMapping}
}

# Function name to selector mapping
FUNCTION_NAMES_TO_SELECTORS = {
${functionMapping}
}

def get_function_name(selector: str) -> Optional[str]:
    """Get function name from selector"""
    return FUNCTION_SELECTORS.get(selector)

def get_function_selector(function_name: str) -> Optional[str]:
    """Get selector from function name"""
    return FUNCTION_NAMES_TO_SELECTORS.get(function_name)

def is_known_function(selector: str) -> bool:
    """Check if selector is known"""
    return selector in FUNCTION_SELECTORS

def is_known_function_name(function_name: str) -> bool:
    """Check if function name is known"""
    return function_name in FUNCTION_NAMES_TO_SELECTORS
`;
    }

    /**
     * Compute function selector (first 4 bytes of keccak256 hash of canonical signature)
     */
    private computeFunctionSelector(canonicalSignature: string): string {
        // This is a simplified implementation - in practice, you'd use a proper keccak256 library
        const hash = this.simpleKeccak256(canonicalSignature);
        return `0x${hash.slice(0, 8)}`; // First 4 bytes (8 hex characters)
    }

    /**
     * Simple keccak256 implementation for generation time
     * In a real implementation, this would use a proper keccak256 library
     */
    private simpleKeccak256(input: string): string {
        // This is a placeholder implementation
        // In practice, you'd use a proper keccak256 library like 'js-sha3' or 'ethers'
        const crypto = require('crypto');
        const hash = crypto.createHash('sha3-256');
        hash.update(input);
        return hash.digest('hex');
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
