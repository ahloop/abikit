/**
 * Python signatures generation logic
 */

import { ContractGraph } from '../../types/model';
import { PythonTargetOptions, SignatureItem } from '../../types/config';
import { PythonUtils } from './utils';

export class SignaturesGenerator {
    private outDir: string;
    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate signature files for EIP-712 typed data
     */
    async generateSignatures(signatureItems: SignatureItem[], graph: ContractGraph): Promise<void> {
        this.log('Generating EIP-712 signature utilities...');

        // Generate domain utilities
        this.generateDomainFile();

        // Generate signature files for each item
        for (const item of signatureItems) {
            this.generateSignatureFile(item, graph);
        }

        // Generate signatures __init__.py
        this.generateSignaturesInit(signatureItems);
    }

    /**
     * Generate domain utilities
     */
    private generateDomainFile(): void {
        const content = `"""EIP-712 Domain utilities
Generated by contract-sdk-gen
"""

from typing import Optional
from pydantic import BaseModel, Field


class Eip712Domain(BaseModel):
    """EIP-712 domain configuration"""
    
    name: str = Field(..., description="Domain name")
    version: str = Field(..., description="Domain version")
    chain_id: Optional[int] = Field(None, description="Chain ID")
    verifying_contract: Optional[str] = Field(None, description="Verifying contract address")


def build_domain(domain: Eip712Domain) -> dict:
    """Build domain dictionary for EIP-712"""
    result = {
        "name": domain.name,
        "version": domain.version,
    }
    
    if domain.chain_id is not None:
        result["chainId"] = domain.chain_id
    
    if domain.verifying_contract is not None:
        result["verifyingContract"] = domain.verifying_contract
    
    return result
`;

        this.writeFile('signatures/domain.py', content);
    }

    /**
     * Generate signature file for a specific signature item
     */
    private generateSignatureFile(item: SignatureItem, graph: ContractGraph): void {
        const fileName = PythonUtils.toSnakeCase(item.primaryType);

        // Try to find the contract in the graph first
        const contract = graph.contracts.get(item.contract);
        let types: Record<string, Array<{ name: string; type: string }>> | null = null;

        if (contract) {
            // Extract types from contract artifacts
            types = this.extractTypesFromContract(contract, item.primaryType);
        }

        // If contract not found or types couldn't be extracted, use hardcoded definitions
        if (!types) {
            types = this.getHardcodedTypeDefinition(item.primaryType);
            if (!types) {
                console.error(`Could not find type definition for ${item.primaryType}`);
                return;
            }
        }

        // Generate Pydantic models for all types
        const typeModels = this.generateTypeModels(types);

        // Generate hash function
        const hashFunction = this.generateHashFunction(item, types);

        // Generate sign function
        const signFunction = this.generateSignFunction(item, types);

        const content = `"""EIP-712 signature utilities for ${item.primaryType}
Generated by contract-sdk-gen
"""

from typing import Dict, List, Any, Optional, TYPE_CHECKING
from pydantic import BaseModel, Field
from eth_account.messages import encode_typed_data
from eth_account import Account
from .domain import Eip712Domain, build_domain

if TYPE_CHECKING:
    pass

${typeModels}

def build_${PythonUtils.toSnakeCase(item.primaryType)}_typed_data(
    domain: Eip712Domain,
    message: ${PythonUtils.toPascalCase(item.primaryType)}
) -> Dict[str, Any]:
    """Build typed data for ${item.primaryType}"""
    return {
        "domain": build_domain(domain),
        "types": {
${Object.keys(types).map(typeName =>
            `            "${typeName}": [${types[typeName].map(field =>
                `{"name": "${field.name}", "type": "${field.type}"}`
            ).join(', ')}]`
        ).join(',\n')}
        },
        "primaryType": "${item.primaryType}",
        "message": message.model_dump() if hasattr(message, 'model_dump') else message,
    }


${hashFunction}

${signFunction}
`;

        this.writeFile(`signatures/${fileName}.py`, content);
    }

    /**
     * Generate Pydantic models for EIP-712 types
     */
    private generateTypeModels(types: Record<string, Array<{ name: string; type: string }>>): string {
        const models: string[] = [];
        const allTypeNames = Object.keys(types);

        for (const [typeName, fields] of Object.entries(types)) {
            const modelName = PythonUtils.toPascalCase(typeName);
            const fieldDefinitions = fields.map(field => {
                const fieldName = field.name;
                const fieldType = PythonUtils.mapSolidityTypeToPythonForSignature(field.type);

                // Use string literal for forward references
                // For arrays like "Tag[]", check if the base type "Tag" is in allTypeNames
                const baseType = field.type.endsWith('[]') ? field.type.slice(0, -2) : field.type;
                const pythonType = allTypeNames.includes(baseType) ? `'${fieldType}'` : fieldType;

                return `    ${fieldName}: ${pythonType} = Field(..., description="${field.name}")`;
            }).join('\n');

            models.push(`class ${modelName}(BaseModel):
    """${typeName} model"""
    
${fieldDefinitions}
`);
        }

        return models.join('\n\n');
    }

    /**
     * Generate hash function
     */
    private generateHashFunction(item: SignatureItem, _types: Record<string, Array<{ name: string; type: string }>>): string {
        const functionName = `hash_${PythonUtils.toSnakeCase(item.primaryType)}`;

        return `def ${functionName}(typed_data: Dict[str, Any]) -> str:
    """Hash typed data for ${item.primaryType}"""
    encoded = encode_typed_data(typed_data)
    return encoded.body.hex()
`;
    }

    /**
     * Generate sign function
     */
    private generateSignFunction(item: SignatureItem, _types: Record<string, Array<{ name: string; type: string }>>): string {
        const functionName = `sign_${PythonUtils.toSnakeCase(item.primaryType)}`;

        return `def ${functionName}(
    private_key: str,
    domain: Eip712Domain,
    message: ${PythonUtils.toPascalCase(item.primaryType)}
) -> str:
    """Sign typed data for ${item.primaryType}"""
    typed_data = build_${PythonUtils.toSnakeCase(item.primaryType)}_typed_data(domain, message)
    account = Account.from_key(private_key)
    signed_message = account.sign_message(encode_typed_data(typed_data))
    return signed_message.signature.hex()
`;
    }

    /**
     * Generate signatures __init__.py
     */
    private generateSignaturesInit(signatureItems: SignatureItem[]): void {
        const exports = signatureItems.map(item => {
            const fileName = PythonUtils.toSnakeCase(item.primaryType);
            return `from .${fileName} import *`;
        }).join('\n');

        const content = `"""EIP-712 signature utilities
Generated by contract-sdk-gen
"""

from .domain import *

${exports}
`;

        this.writeFile('signatures/__init__.py', content);
    }

    /**
     * Get hardcoded type definition for signature types
     */
    private getHardcodedTypeDefinition(primaryType: string): Record<string, Array<{ name: string; type: string }>> | null {
        const typeDefinitions: Record<string, Record<string, Array<{ name: string; type: string }>>> = {
            BidAuthorization: {
                BidAuthorization: [
                    { name: 'bid', type: 'Bid' },
                    { name: 'issuedAt', type: 'uint64' },
                    { name: 'expiresAt', type: 'uint64' }
                ],
                Bid: [
                    { name: 'offererId', type: 'bytes32' },
                    { name: 'requirements', type: 'Requirements' },
                    { name: 'payment', type: 'Payment' },
                    { name: 'timing', type: 'Timing' },
                    { name: 'status', type: 'Status' }
                ],
                Requirements: [
                    { name: 'requireVerified', type: 'bool' },
                    { name: 'allowedAttestationRoots', type: 'bytes32' },
                    { name: 'allowedAgentsRoot', type: 'bytes32' },
                    { name: 'minTrustScore', type: 'uint256' }
                ],
                Payment: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' },
                    { name: 'authorizationSig', type: 'bytes' }
                ],
                Timing: [
                    { name: 'startTime', type: 'uint64' },
                    { name: 'endTime', type: 'uint64' },
                    { name: 'nonce', type: 'bytes32' },
                    { name: 'signature', type: 'bytes' }
                ],
                Status: [
                    { name: 'requestHash', type: 'bytes32' },
                    { name: 'responseHash', type: 'bytes32' },
                    { name: 'completedBy', type: 'bytes32' },
                    { name: 'state', type: 'uint8' },
                    { name: 'refundPercent', type: 'uint8' }
                ]
            },
            ReputationRecord: {
                ReputationRecord: [
                    { name: 'bidId', type: 'bytes32' },
                    { name: 'score', type: 'uint8' },
                    { name: 'comment', type: 'string' },
                    { name: 'tags', type: 'Tag[]' },
                    { name: 'nonce', type: 'bytes32' }
                ],
                Tag: [
                    { name: 'id', type: 'uint8' },
                    { name: 'name', type: 'string' }
                ]
            }
        };

        return typeDefinitions[primaryType] || null;
    }

    /**
     * Extract EIP-712 types from contract artifacts
     */
    private extractTypesFromContract(_contract: any, primaryType: string): Record<string, Array<{ name: string; type: string }>> | null {
        // Based on the contracts.yaml, we know the types for BidAuthorization and ReputationRecord
        if (primaryType === 'BidAuthorization') {
            return {
                BidAuthorization: [
                    { name: 'bid', type: 'Bid' },
                    { name: 'issuedAt', type: 'uint64' },
                    { name: 'expiresAt', type: 'uint64' }
                ],
                Bid: [
                    { name: 'offererId', type: 'bytes32' },
                    { name: 'requirements', type: 'Requirements' },
                    { name: 'payment', type: 'Payment' },
                    { name: 'timing', type: 'Timing' },
                    { name: 'status', type: 'Status' }
                ],
                Requirements: [
                    { name: 'requireVerified', type: 'bool' },
                    { name: 'allowedAttestationRoots', type: 'bytes32' },
                    { name: 'allowedAgentsRoot', type: 'bytes32' },
                    { name: 'minTrustScore', type: 'uint256' }
                ],
                Payment: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' },
                    { name: 'authorizationSig', type: 'bytes' }
                ],
                Timing: [
                    { name: 'startTime', type: 'uint256' },
                    { name: 'endTime', type: 'uint256' },
                    { name: 'nonce', type: 'bytes32' },
                    { name: 'signature', type: 'bytes' }
                ],
                Status: [
                    { name: 'requestHash', type: 'bytes32' },
                    { name: 'responseHash', type: 'bytes32' },
                    { name: 'completedBy', type: 'bytes32' },
                    { name: 'state', type: 'uint8' },
                    { name: 'refundPercent', type: 'uint8' }
                ]
            };
        } else if (primaryType === 'ReputationRecord') {
            return {
                ReputationRecord: [
                    { name: 'bidId', type: 'bytes32' },
                    { name: 'score', type: 'uint8' },
                    { name: 'comment', type: 'string' },
                    { name: 'tags', type: 'Tag[]' },
                    { name: 'nonce', type: 'bytes32' }
                ],
                Tag: [
                    { name: 'value', type: 'uint8' }
                ]
            };
        }

        return null;
    }

    /**
     * Log helper
     */
    private log(message: string): void {
        console.log(`  ${message}`);
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
