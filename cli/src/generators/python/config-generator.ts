/**
 * Python config generation logic
 */

import { ContractGraph } from '../../types/model';
import { PythonTargetOptions } from '../../types/config';
import { GeneratorContext } from '../base';

export class ConfigGenerator {
    private outDir: string;
    constructor(outDir: string, _options: PythonTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate config package
     */
    async generateConfig(graph: ContractGraph, context: GeneratorContext): Promise<void> {
        this.log('Generating config package...');

        // Generate addresses.py
        this.generateAddressesPy(graph, context);

        // Generate runtime_config.py
        this.generateRuntimeConfigPy(graph, context);

        // Generate config __init__.py
        this.writeFile('config/__init__.py', `"""
Auto-generated config utilities
Generated by contract-sdk-gen
"""

from .addresses import *
from .runtime_config import *
`);
    }

    /**
     * Generate addresses.py
     */
    private generateAddressesPy(graph: ContractGraph, context: GeneratorContext): void {
        const contractNames = Array.from(graph.contracts.keys())
            .filter(name => !graph.contracts.get(name)?.isInterface)
            .sort();

        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        // Convert network names to valid Python identifiers
        const pythonNetworkNames = networkNames.map(name => name.replace('-', '_'));

        const content = `"""
Auto-generated contract addresses by network
Generated by contract-sdk-gen
"""

from typing import Dict, Optional, TypedDict


class NetworkAddresses(TypedDict, total=False):
${contractNames.map(name => `    ${name}: Optional[str]`).join('\n')}


class NetworkContracts(TypedDict):
${pythonNetworkNames.map(network => `    ${network}: NetworkAddresses`).join('\n')}


NETWORK_CONTRACTS: NetworkContracts = {
${pythonNetworkNames.map((pythonNetwork, index) => {
            const originalNetwork = networkNames[index];
            const networkConfig = networks[originalNetwork];
            return `    '${pythonNetwork}': {
${contractNames.map(contractName => {
                const address = networkConfig?.contracts?.[contractName] || '0x0000000000000000000000000000000000000000';
                return `        '${contractName}': '${address}'`;
            }).join(',\n')}
    }`;
        }).join(',\n')}
}


def get_contract_address(network: str, contract: str) -> str:
    """Get contract address by network and contract name"""
    if network not in NETWORK_CONTRACTS:
        raise ValueError(f'Network {network} not found')
    
    address = NETWORK_CONTRACTS[network].get(contract)
    if not address:
        raise ValueError(f'Contract {contract} not found for network {network}')
    
    return address


def get_available_networks() -> list[str]:
    """Get all available networks"""
    return list(NETWORK_CONTRACTS.keys())


def get_network_contracts(network: str) -> NetworkAddresses:
    """Get all contracts for a network"""
    if network not in NETWORK_CONTRACTS:
        raise ValueError(f'Network {network} not found')
    
    return NETWORK_CONTRACTS[network]
`;

        this.writeFile('config/addresses.py', content);
    }

    /**
     * Generate runtime_config.py
     */
    private generateRuntimeConfigPy(_graph: ContractGraph, context: GeneratorContext): void {
        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        const content = `"""
Auto-generated runtime configuration
Generated by contract-sdk-gen
"""

from typing import Dict, TypedDict
from .addresses import NetworkAddresses


class NetworkConfig(TypedDict):
    chain_id: int
    name: str
    rpc: str
    explorer: str
    contracts: NetworkAddresses


class RuntimeConfig(TypedDict):
    networks: Dict[str, NetworkConfig]
    version: str


runtime_config: RuntimeConfig = {
    'networks': {
${networkNames.map(network => {
            const networkConfig = networks[network];
            return `        '${network}': {
            'chain_id': ${networkConfig?.chainId || 0},
            'name': '${networkConfig?.name || network}',
            'rpc': '${networkConfig?.rpc || 'undefined'}',
            'explorer': '${networkConfig?.explorer || 'undefined'}',
            'contracts': {
${Object.entries(networkConfig?.contracts || {}).map(([contract, address]) =>
                `                '${contract}': '${address}'`
            ).join(',\n')}
            }
        }`;
        }).join(',\n')}
    },
    'version': '${context.fullConfig?.generation?.targets?.[0]?.options?.packageVersion || '1.0.0'}'
}
`;

        this.writeFile('config/runtime_config.py', content);
    }

    /**
     * Log helper
     */
    private log(message: string): void {
        console.log(`  ${message}`);
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
