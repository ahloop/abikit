/**
 * TypeScript SDK generator (viem-first)
 */

import { BaseGenerator } from './base';
import { ContractGraph, ContractModel, Parameter, SolidityType, FunctionModel, EventModel } from '../types/model';
import { TargetConfig, TypeScriptTargetOptions } from '../types/config';

export class TypeScriptGenerator extends BaseGenerator {
    protected options: TypeScriptTargetOptions;

    constructor(outDir: string, options: TypeScriptTargetOptions = {}) {
        super(outDir, options);
        this.options = {
            transport: 'viem',
            emitHooks: false,
            bigintStyle: 'native',
            emitStructsOnly: true,
            packageName: 'contract-sdk',
            ...options,
        };
    }

    getName(): string {
        return 'TypeScript Generator (viem)';
    }

    validateOptions(options: any): void {
        if (options.transport && !['viem', 'ethers'].includes(options.transport)) {
            throw new Error('transport must be "viem" or "ethers"');
        }
        if (options.bigintStyle && !['native', 'bn.js'].includes(options.bigintStyle)) {
            throw new Error('bigintStyle must be "native" or "bn.js"');
        }
    }

    async generate(graph: ContractGraph, _config: TargetConfig): Promise<void> {
        this.ensureOutDir();
        this.log(`Generating TypeScript SDK with ${this.options.transport}...`);

        // Generate shared types file FIRST to avoid duplicates
        this.generateSharedTypesFile(Array.from(graph.contracts.values()));

        // Generate contracts
        for (const [_contractName, contract] of graph.contracts.entries()) {
            this.generateContractFile(contract);
        }

        // Generate config files
        this.generateConfigFiles(graph);

        // Generate utils
        this.generateUtils();

        // Generate package.json with exports
        this.generatePackageJson(graph);

        // Generate root index
        this.generateIndex(graph);

        // Generate comprehensive index
        this.generateComprehensiveIndex(graph);

        // Generate hooks if enabled
        if (this.options.emitHooks) {
            this.generateHooks(graph);
        }

        this.logSuccess(`Generated TypeScript SDK to ${this.outDir}`);
    }

    /**
     * Generate shared types file to avoid duplicates
     */
    private generateSharedTypesFile(contracts: ContractModel[]): void {
        // Collect all unique structs across all contracts
        const allStructs = new Map<string, any>();

        for (const contract of contracts) {
            for (const struct of contract.structs) {
                if (!allStructs.has(struct.name)) {
                    allStructs.set(struct.name, struct);
                }
            }
        }

        if (allStructs.size === 0) {
            return; // No structs to generate
        }

        // Check if any structs use viem types
        const usesAddress = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'address')
        );
        const usesHash = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'bytes32')
        );
        const usesHex = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'bytes')
        );

        const viemTypes: string[] = [];
        if (usesAddress) viemTypes.push('Address');
        if (usesHash) viemTypes.push('Hash');
        if (usesHex) viemTypes.push('Hex');

        const viemImport = viemTypes.length > 0
            ? `import type { ${viemTypes.join(', ')} } from 'viem';\n`
            : '';

        const content = `// Auto-generated shared types
// Generated by contract-sdk-gen

${viemImport}
${Array.from(allStructs.values()).map(struct => `export interface ${struct.name} {
${struct.fields.map((field: any) => `  ${field.name}: ${this.mapSolidityTypeToTS(field, contracts[0])};`).join('\n')}
}
`).join('\n')}`;

        this.writeFile('src/types/index.ts', content);
    }

    /**
     * Generate per-contract folder structure
     */
    private generateContractFile(contract: ContractModel): void {
        const contractName = contract.name;
        const folderPrefix = contract.isInterface ? 'interfaces' : 'contracts';

        // Generate ABI file
        const abiContent = this.renderAbiTemplate(contract);
        this.writeFile(`src/${folderPrefix}/${contractName}/abi.ts`, abiContent);

        // Generate contract wrapper
        const contractContent = this.renderContractTemplate(contract);
        this.writeFile(`src/${folderPrefix}/${contractName}/contract.ts`, contractContent);

        // Generate contract-specific types (only if contract has unique types)
        const uniqueTypes = this.getUniqueTypes(contract);
        if (uniqueTypes.length > 0) {
            const typesContent = this.renderContractTypesTemplate(contract, uniqueTypes);
            this.writeFile(`src/${folderPrefix}/${contractName}/types.ts`, typesContent);
        }

        // Generate barrel index
        const indexContent = this.renderContractIndexTemplate(contract, uniqueTypes.length > 0);
        this.writeFile(`src/${folderPrefix}/${contractName}/index.ts`, indexContent);
    }



    /**
     * Render ABI file
     */
    private renderAbiTemplate(contract: ContractModel): string {
        return `// Auto-generated ABI for ${contract.name}
// Generated by contract-sdk-gen v${require('../../package.json').version}

export const ${contract.name.toUpperCase()}_ABI = ${JSON.stringify(contract.abi, null, 2)} as const;
`;
    }

    /**
     * Get unique types for a contract (not in common/types)
     */
    private getUniqueTypes(_contract: ContractModel): any[] {
        // For now, return empty - all structs go to common/types
        // In the future, this could detect contract-specific types
        return [];
    }

    /**
     * Render contract-specific types file
     */
    private renderContractTypesTemplate(contract: ContractModel, _uniqueTypes: any[]): string {
        return `// Auto-generated types for ${contract.name}
// Generated by contract-sdk-gen

// Contract-specific types (not in common/types)
// Currently empty - all shared types are in common/types.ts
`;
    }

    /**
     * Render contract barrel index
     */
    private renderContractIndexTemplate(contract: ContractModel, hasTypes: boolean): string {
        const typeExports = hasTypes ? `export * from './types';` : '';

        return `// Auto-generated barrel index for ${contract.name}
// Generated by contract-sdk-gen

export { ${contract.name} } from './contract';
export type { ${contract.name}Config } from './contract';
export { ${contract.name.toUpperCase()}_ABI } from './abi';
${typeExports}
`;
    }

    /**
     * Render contract template
     */
    private renderContractTemplate(contract: ContractModel): string {
        const usesAddress = this.contractUsesType(contract, 'address');
        const usesBytes32 = this.contractUsesType(contract, 'bytes32');
        const usesBytes = this.contractUsesType(contract, 'bytes');

        const viemTypes: string[] = ['Hash']; // Always need Hash for write functions
        if (usesAddress) viemTypes.push('Address');
        if (usesBytes32 && !viemTypes.includes('Hash')) viemTypes.push('Hash');
        if (usesBytes) viemTypes.push('Hex');

        const viemImport = viemTypes.length > 0
            ? `import type { ${viemTypes.join(', ')} } from 'viem';`
            : '';

        const hasStructs = contract.structs.length > 0;
        const typesImport = hasStructs
            ? `import type { ${contract.structs.map(s => s.name).join(', ')} } from '../../types';`
            : '';

        return `// Auto-generated contract wrapper for ${contract.name}
// Generated by contract-sdk-gen v${require('../../package.json').version}

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
${viemImport}
${typesImport}
import { ${contract.name.toUpperCase()}_ABI } from './abi';

export interface ${contract.name}Config {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class ${contract.name} {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: ${contract.name}Config) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

${contract.functions.filter((func, index, arr) => arr.findIndex(f => f.name === func.name) === index).map(func => this.renderFunctionMethod(func, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventLogsMethod(event, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventMethod(event, contract)).join('\n\n')}
}
`;
    }

    /**
     * Render function method
     */
    private renderFunctionMethod(func: FunctionModel, contract: ContractModel): string {
        const params = func.inputs.map((input, idx) =>
            `${input.name || `arg${idx}`}: ${this.mapSolidityTypeToTS(input, contract)}`
        ).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
        const returnType = isReadOnly
            ? (func.outputs.length === 0
                ? 'void'
                : func.outputs.length === 1
                    ? this.mapSolidityTypeToTS(func.outputs[0], contract)
                    : `[${func.outputs.map(o => this.mapSolidityTypeToTS(o, contract)).join(', ')}]`)
            : 'Hash';

        const argsArray = func.inputs.length > 0 ? `[${func.inputs.map((i, idx) => i.name || `arg${idx}`).join(', ')}]` : '[]';
        const argsWithTypeAssertion = func.inputs.length > 0 ? `${argsArray} as any` : argsArray;

        return `  /**
   * ${func.name}
   * ${func.stateMutability}
   */
  async ${func.name}(${params}): Promise<${returnType}> {
    ${isReadOnly
                ? `if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
    }) as ${returnType};`
                : `if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });`
            }
  }`;
    }

    /**
     * Render event method
     */
    private renderEventMethod(event: EventModel, contract: ContractModel): string {
        return `  /**
   * Watch ${event.name} events
   */
  watch${event.name}(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      eventName: '${event.name}',
      onLogs,
    });
  }`;
    }

    /**
     * Render event logs method
     */
    private renderEventLogsMethod(event: EventModel, contract: ContractModel): string {
        const indexedParams = event.inputs.filter(p => p.indexed);
        const params = indexedParams.map(p =>
            `${p.name}?: ${this.mapSolidityTypeToTS(p, contract)}`
        ).join(', ');

        const argsFilter = indexedParams.length > 0
            ? `args: { ${indexedParams.map(p => `${p.name}: options?.${p.name}`).join(', ')} }`
            : '';

        return `  /**
   * Get ${event.name} event logs
   */
  async get${event.name}Logs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    ${params ? params + ';' : ''}
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ${contract.name.toUpperCase()}_ABI.find(e => e.type === 'event' && e.name === '${event.name}'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      ${argsFilter}
    }) as any[];
  }`;
    }

    /**
     * Map Solidity type to TypeScript type
     */
    private mapSolidityTypeToTS(param: Parameter, contract: ContractModel): string {
        const { type, internalType, components } = param;

        // Handle arrays
        if (type.endsWith('[]')) {
            const baseType = type.slice(0, -2);
            const baseParam = { ...param, type: baseType as SolidityType };
            return `${this.mapSolidityTypeToTS(baseParam, contract)}[]`;
        }

        // Handle tuples (structs)
        if (type === 'tuple' && components) {
            const structName = this.extractStructName(internalType);
            if (structName) {
                return structName;
            }
            return `{ ${components.map(c => `${c.name}: ${this.mapSolidityTypeToTS(c, contract)}`).join('; ')} }`;
        }

        // Basic type mapping
        const typeMap: Record<string, string> = {
            'address': 'Address',
            'bool': 'boolean',
            'string': 'string',
            'bytes': 'Hex',
            'bytes32': 'Hash',
            'uint8': 'number',
            'uint16': 'number',
            'uint32': 'number',
            'uint48': 'number',
            'uint64': 'bigint',
            'uint128': 'bigint',
            'uint160': 'bigint',
            'uint256': 'bigint',
            'int256': 'bigint',
        };

        return typeMap[type] || 'unknown';
    }

    /**
     * Extract struct name from internalType
     */
    private extractStructName(internalType?: string): string | null {
        if (!internalType || !internalType.includes('struct ')) {
            return null;
        }
        const match = internalType.match(/struct\s+([^\s\[\]]+)/);
        if (match) {
            const fullName = match[1];
            return fullName.includes('.') ? fullName.split('.').pop()! : fullName;
        }
        return null;
    }

    /**
     * Check if contract uses a specific type
     */
    private contractUsesType(contract: ContractModel, type: string): boolean {
        const checkParam = (param: Parameter): boolean => {
            // Strip array suffix for comparison
            const baseType = param.type.replace(/\[\]$/, '');
            if (baseType === type) return true;
            if (param.components) {
                return param.components.some(checkParam);
            }
            return false;
        };

        return contract.functions.some(func =>
            func.inputs.some(checkParam) || func.outputs.some(checkParam)
        ) || contract.events.some(event =>
            event.inputs.some(checkParam)
        );
    }


    /**
     * Generate config files
     */
    private generateConfigFiles(graph: ContractGraph): void {
        this.log('Generating config files...');

        // Generate runtime config from networks in the contract graph
        if (graph.networks && graph.networks.size > 0) {
            const networksObj: Record<string, any> = {};
            for (const [name, network] of graph.networks.entries()) {
                networksObj[name] = {
                    chainId: network.chainId,
                    name: network.name,
                    rpc: network.rpc,
                    explorer: network.explorer,
                    contracts: network.contracts,
                };
            }

            const configContent = JSON.stringify({
                networks: networksObj,
                version: this.options.packageVersion || '1.0.0',
            }, null, 2);

            this.writeFile('src/config/runtime-config.json', configContent);
        }
    }

    /**
     * Generate utility files
     */
    private generateUtils(): void {
        // TODO: Generate utils (abi, events, tx, eip712)
        this.log('Generating utils...');
    }

    /**
     * Generate package.json with subpath exports
     */
    private generatePackageJson(graph?: ContractGraph): void {
        const exports: Record<string, string> = {
            '.': './dist/index.js',
            './types': './dist/types/index.js',
            './all': './dist/all.js',
        };

        // Add per-contract exports
        if (graph) {
            for (const [contractName, contract] of graph.contracts.entries()) {
                const folderPrefix = contract.isInterface ? 'interfaces' : 'contracts';
                exports[`./${contractName}`] = `./dist/${folderPrefix}/${contractName}/index.js`;
            }
        }

        const packageJson = {
            name: this.options.packageName || 'contract-sdk',
            version: this.options.packageVersion || '1.0.0',
            main: 'dist/index.js',
            types: 'dist/index.d.ts',
            exports,
            scripts: {
                build: 'tsc',
                test: 'vitest',
            },
            dependencies: {
                viem: '^2.21.0',
            },
            devDependencies: {
                typescript: '^5.0.0',
                vitest: '^1.0.0',
            },
        };

        this.writeFile('package.json', JSON.stringify(packageJson, null, 2));
    }

    /**
     * Generate root barrel index
     */
    private generateIndex(graph: ContractGraph): void {
        const contracts = Array.from(graph.contracts.values());

        const contractExports = contracts
            .filter(c => !c.isInterface)
            .map(c => `export * from './contracts/${c.name}';`)
            .join('\n');

        const interfaceExports = contracts
            .filter(c => c.isInterface)
            .map(c => `export * from './interfaces/${c.name}';`)
            .join('\n');

        // Export types
        const typeExports = `export * from './types';`;

        const exports = [contractExports, interfaceExports, typeExports].filter(Boolean).join('\n\n');

        this.writeFile('src/index.ts', `// Auto-generated root barrel\n// Consumers should import from specific contracts: '@yourpackage/contracts/<ContractName>'\n\n${exports}\n`);
    }

    /**
     * Generate comprehensive index with all exports
     */
    private generateComprehensiveIndex(graph: ContractGraph): void {
        const contracts = Array.from(graph.contracts.values());

        // All contract classes
        const contractClasses = contracts
            .filter(c => !c.isInterface)
            .map(c => c.name);

        // All interface classes  
        const interfaceClasses = contracts
            .filter(c => c.isInterface)
            .map(c => c.name);

        // All contract configs
        const contractConfigs = contracts
            .filter(c => !c.isInterface)
            .map(c => `${c.name}Config`);

        // All interface configs
        const interfaceConfigs = contracts
            .filter(c => c.isInterface)
            .map(c => `${c.name}Config`);

        // All ABIs
        const abis = contracts
            .map(c => `${c.name.toUpperCase()}_ABI`);

        const content = `// Comprehensive index - exports everything
// Generated by contract-sdk-gen

// ===== CONTRACT CLASSES =====
${contractClasses.map(name => `export { ${name} } from './contracts/${name}';`).join('\n')}

// ===== INTERFACE CLASSES =====
${interfaceClasses.map(name => `export { ${name} } from './interfaces/${name}';`).join('\n')}

// ===== CONTRACT CONFIGS =====
${contractConfigs.map(name => `export type { ${name} } from './contracts/${name.replace('Config', '')}';`).join('\n')}

// ===== INTERFACE CONFIGS =====
${interfaceConfigs.map(name => `export type { ${name} } from './interfaces/${name.replace('Config', '')}';`).join('\n')}

// ===== ABIs =====
${abis.map(abi => {
            const contractName = abi.replace('_ABI', '');
            const contract = contracts.find(c => c.name.toUpperCase() === contractName);
            if (!contract) return '';
            const folder = contract.isInterface ? 'interfaces' : 'contracts';
            return `export { ${abi} } from './${folder}/${contract.name}';`;
        }).filter(Boolean).join('\n')}

// ===== SHARED TYPES =====
export * from './types';

// ===== UTILITIES =====
// TODO: Add utility exports when implemented

// ===== CONVENIENCE EXPORTS =====
// Import all contracts for convenience objects
${contractClasses.map(name => `import { ${name} } from './contracts/${name}';`).join('\n')}
${interfaceClasses.map(name => `import { ${name} } from './interfaces/${name}';`).join('\n')}
${abis.map(abi => {
            const contractName = abi.replace('_ABI', '');
            const contract = contracts.find(c => c.name.toUpperCase() === contractName);
            if (!contract) return '';
            const folder = contract.isInterface ? 'interfaces' : 'contracts';
            return `import { ${abi} } from './${folder}/${contract.name}';`;
        }).filter(Boolean).join('\n')}

// All contracts as a single object
export const CONTRACTS = {
${contractClasses.map(name => `  ${name},`).join('\n')}
} as const;

// All interfaces as a single object  
export const INTERFACES = {
${interfaceClasses.map(name => `  ${name},`).join('\n')}
} as const;

// All ABIs as a single object
export const ABIS = {
${abis.map(abi => `  ${abi},`).join('\n')}
} as const;

// Type helpers
export type ContractName = keyof typeof CONTRACTS;
export type InterfaceName = keyof typeof INTERFACES;
export type ContractClass = typeof CONTRACTS[ContractName];
export type InterfaceClass = typeof INTERFACES[InterfaceName];
`;

        this.writeFile('src/all.ts', content);
    }

    /**
     * Generate wagmi hooks
     */
    private generateHooks(_graph: ContractGraph): void {
        if (!this.options.emitHooks) return;
        this.log('Generating wagmi hooks...');
        // TODO: Implement hooks generation
    }
}