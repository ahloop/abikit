/**
 * TypeScript events generation logic
 */

import { ContractModel, EventModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';
import { TypeScriptUtils } from './utils';

export class EventsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate events file for a contract
     */
    async generateEvents(contract: ContractModel): Promise<void> {
        if (contract.events.length === 0) {
            return; // Skip if no events
        }

        const content = this.renderEventsTemplate(contract);
        this.writeFile(`src/contracts/${contract.name}/events.ts`, content);
    }

    /**
     * Render events template
     */
    private renderEventsTemplate(contract: ContractModel): string {
        const contractName = contract.name;
        const abiName = `${contractName.toUpperCase()}_ABI`;

        // Generate event signatures
        const eventSignatures = contract.events.map(event => {
            const canonicalSig = EventModel.getCanonicalSignature(event);
            const constantName = `${event.name.toUpperCase()}_EVENT_SIGNATURE`;
            return `export const ${constantName} = '${this.computeEventSignature(canonicalSig)}';`;
        }).join('\n');

        // Generate event type definitions
        const eventTypes = contract.events.map(event => {
            const interfaceName = `${event.name}Event`;
            const fields = event.inputs.map(input => {
                const tsType = TypeScriptUtils.mapSolidityTypeToTS(input, contract);
                return `  ${input.name}: ${tsType};`;
            }).join('\n');

            return `export interface ${interfaceName} {
${fields}
}`;
        }).join('\n\n');

        // Generate decode functions
        const decodeFunctions = contract.events.map(event => {
            const interfaceName = `${event.name}Event`;
            return `export function decode${event.name}Event(log: Log): ${interfaceName} {
  const decoded = decodeEventLog({
    abi: ${abiName},
    data: log.data,
    topics: log.topics,
    eventName: '${event.name}',
  });
  return decoded.args as ${interfaceName};
}`;
        }).join('\n\n');

        // Generate helper functions
        const helperFunctions = contract.events.map(event => {
            const constantName = `${event.name.toUpperCase()}_EVENT_SIGNATURE`;
            const interfaceName = `${event.name}Event`;

            return `export function has${event.name}Event(logs: Log[]): boolean {
  return logs.some(log => log.topics[0] === ${constantName});
}

export function find${event.name}Events(logs: Log[]): ${interfaceName}[] {
  return logs
    .filter(log => log.topics[0] === ${constantName})
    .map(log => decode${event.name}Event(log));
}`;
        }).join('\n\n');

        // Generate filter builders
        const filterBuilders = contract.events.map(event => {
            const indexedParams = event.inputs.filter(p => p.indexed);
            const params = indexedParams.map(p =>
                `${p.name}?: ${TypeScriptUtils.mapSolidityTypeToTS(p, contract)}`
            ).join(', ');

            const argsFilter = indexedParams.length > 0
                ? `args: { ${indexedParams.map(p => `${p.name}: options?.${p.name}`).join(', ')} }`
                : '';

            return `export function create${event.name}EventFilter(options?: {
  fromBlock?: bigint;
  toBlock?: bigint;
  ${params ? params + ';' : ''}
}) {
  return {
    address: undefined, // Will be set by caller
    event: ${abiName}.find(e => e.type === 'event' && e.name === '${event.name}'),
    fromBlock: options?.fromBlock,
    toBlock: options?.toBlock,
    ${argsFilter}
  };
}`;
        }).join('\n\n');

        return `// Auto-generated events for ${contractName}
// Generated by contract-sdk-gen

import { decodeEventLog, type Log } from 'viem';
import type { Address, Hash } from 'viem';
import { ${abiName} } from './abi';

// Event signatures
${eventSignatures}

// Event type definitions
${eventTypes}

// Decode functions
${decodeFunctions}

// Helper functions
${helperFunctions}

// Filter builders
${filterBuilders}
`;
    }

    /**
     * Compute event signature (keccak256 hash of canonical signature)
     * This is a simplified implementation - in practice, you'd use a proper keccak256 library
     */
    private computeEventSignature(canonicalSignature: string): string {
        // For now, return a placeholder. In a real implementation, you'd use:
        // import { keccak256, toHex } from 'viem';
        // return keccak256(toHex(canonicalSignature));

        // This is a placeholder that should be replaced with actual keccak256 computation
        // The actual implementation would need to be done at generation time
        return `0x${this.simpleKeccak256(canonicalSignature)}`;
    }

    /**
     * Simple keccak256 implementation for generation time
     * In a real implementation, this would use a proper crypto library
     */
    private simpleKeccak256(input: string): string {
        // This is a placeholder implementation
        // In practice, you'd use a proper keccak256 library like 'js-sha3' or 'ethers'
        const crypto = require('crypto');
        const hash = crypto.createHash('sha3-256');
        hash.update(input);
        return hash.digest('hex');
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
