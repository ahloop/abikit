/**
 * TypeScript selectors generation logic
 */

import { ContractModel, FunctionModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';

export class SelectorsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate selectors file for a contract
     */
    async generateSelectors(contract: ContractModel): Promise<void> {
        // Only generate selectors for functions that should have them (public/external)
        const functionsWithSelectors = contract.functions.filter(func =>
            FunctionModel.shouldGenerateSelector(func)
        );

        if (functionsWithSelectors.length === 0) {
            return; // Skip if no functions need selectors
        }

        const content = this.renderSelectorsTemplate(contract, functionsWithSelectors);
        this.writeFile(`src/contracts/${contract.name}/selectors.ts`, content);
    }

    /**
     * Render selectors template
     */
    private renderSelectorsTemplate(contract: ContractModel, functions: FunctionModel[]): string {
        const contractName = contract.name;

        // Generate function selectors
        const functionSelectors = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const selector = this.computeFunctionSelector(canonicalSig);
            const constantName = `${func.name.toUpperCase()}_FUNCTION_SELECTOR`;
            return `export const ${constantName} = '${selector}';`;
        }).join('\n');

        // Generate selector to function name mapping
        const selectorMapping = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const selector = this.computeFunctionSelector(canonicalSig);
            return `  '${selector}': '${func.name}',`;
        }).join('\n');

        // Generate reverse mapping (function name to selector)
        const functionMapping = functions.map(func => {
            const canonicalSig = FunctionModel.getCanonicalSignature(func);
            const selector = this.computeFunctionSelector(canonicalSig);
            return `  '${func.name}': '${selector}',`;
        }).join('\n');

        return `// Auto-generated selectors for ${contractName}
// Generated by contract-sdk-gen

// Function selectors (first 4 bytes of keccak256 of function signature)
${functionSelectors}

// Selector to function name mapping
export const FUNCTION_SELECTORS = {
${selectorMapping}
} as const;

// Function name to selector mapping
export const FUNCTION_NAMES_TO_SELECTORS = {
${functionMapping}
} as const;

// Helper to get function name from selector
export function getFunctionName(selector: string): string | undefined {
  return FUNCTION_SELECTORS[selector as keyof typeof FUNCTION_SELECTORS];
}

// Helper to get selector from function name
export function getFunctionSelector(functionName: string): string | undefined {
  return FUNCTION_NAMES_TO_SELECTORS[functionName as keyof typeof FUNCTION_NAMES_TO_SELECTORS];
}

// Type for all function selectors
export type FunctionSelector = keyof typeof FUNCTION_SELECTORS;

// Type for all function names
export type FunctionName = keyof typeof FUNCTION_NAMES_TO_SELECTORS;
`;
    }

    /**
     * Compute function selector (first 4 bytes of keccak256 hash of canonical signature)
     */
    private computeFunctionSelector(canonicalSignature: string): string {
        // This is a simplified implementation - in practice, you'd use a proper keccak256 library
        const hash = this.simpleKeccak256(canonicalSignature);
        return `0x${hash.slice(0, 8)}`; // First 4 bytes (8 hex characters)
    }

    /**
     * Simple keccak256 implementation for generation time
     * In a real implementation, this would use a proper keccak256 library
     */
    private simpleKeccak256(input: string): string {
        // This is a placeholder implementation
        // In practice, you'd use a proper keccak256 library like 'js-sha3' or 'ethers'
        const crypto = require('crypto');
        const hash = crypto.createHash('sha3-256');
        hash.update(input);
        return hash.digest('hex');
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
