/**
 * TypeScript signatures generation logic
 */

import { ContractGraph } from '../../types/model';
import { SignatureItem } from '../../types/config';
import { TypeScriptTargetOptions } from '../../types/config';
import { StructExtractor } from './struct-extractor';

export class SignaturesGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate signatures package
     */
    async generateSignatures(signatureItems: SignatureItem[], graph: ContractGraph): Promise<void> {
        await this.generateDomain();
        await this.generateSignatureModules(signatureItems, graph);
        await this.generateSignaturesIndex(signatureItems);
    }

    /**
     * Generate domain.ts
     */
    private async generateDomain(): Promise<void> {
        const content = `// Auto-generated EIP-712 domain configuration
// Generated by contract-sdk-gen

export const EIP712_DOMAIN = {
  name: 'Truffle Network',
  version: '1',
  chainId: 1, // Mainnet - should be configurable
} as const;

export type EIP712Domain = typeof EIP712_DOMAIN;
`;

        this.writeFile('src/signatures/domain.ts', content);
    }

    /**
     * Generate individual signature modules
     */
    private async generateSignatureModules(signatureItems: SignatureItem[], graph: ContractGraph): Promise<void> {
        for (const item of signatureItems) {
            const fileName = `src/signatures/${this.toKebabCase(item.primaryType)}.ts`;
            const content = this.renderSignatureModule(item, graph);
            this.writeFile(fileName, content);
        }
    }

    /**
     * Render signature module
     */
    private renderSignatureModule(item: SignatureItem, graph: ContractGraph): string {
        const structName = item.primaryType;

        // Try to extract types from contract ABI first
        let typeDefinition = null;
        const contract = graph.contracts.get(item.contract);
        if (contract) {
            const extractedTypes = StructExtractor.extractStructTypes(contract, structName);
            if (extractedTypes && extractedTypes[structName]) {
                typeDefinition = { fields: extractedTypes[structName] };
            }
        }

        // Fallback to hardcoded types if extraction failed
        if (!typeDefinition) {
            typeDefinition = this.getTypeDefinition(structName);
        }

        if (!typeDefinition) {
            return `// Auto-generated EIP-712 signature for ${structName}
// Generated by contract-sdk-gen

// Type definition not found for ${structName}
export interface ${structName} {
  // TODO: Define fields for ${structName}
}

export const ${structName.toUpperCase()}_TYPES = {
  ${structName}: [
    // TODO: Define type fields for ${structName}
  ],
} as const;
`;
        }

        const fields = typeDefinition.fields.map(field =>
            `  ${field.name}: ${this.mapSolidityTypeToTS(field.type)};`
        ).join('\n');

        return `// Auto-generated EIP-712 signature for ${structName}
// Generated by contract-sdk-gen

export interface ${structName} {
${fields}
}

export const ${structName.toUpperCase()}_TYPES = {
  ${structName}: [
${typeDefinition.fields.map(field => `    { name: '${field.name}', type: '${field.type}' },`).join('\n')}
  ],
} as const;
`;
    }

    /**
     * Generate signatures index
     */
    private async generateSignaturesIndex(signatureItems: SignatureItem[]): Promise<void> {
        const exports = signatureItems.map(item =>
            `export * from './${this.toKebabCase(item.primaryType)}';`
        ).join('\n');

        const content = `// Auto-generated signatures barrel index
// Generated by contract-sdk-gen

export * from './domain';
${exports}
`;

        this.writeFile('src/signatures/index.ts', content);
    }

    /**
     * Get type definition for a signature type
     */
    private getTypeDefinition(typeName: string): { fields: Array<{ name: string; type: string }> } | null {
        // Hardcoded type definitions based on the contracts.yaml
        const typeDefinitions: Record<string, { fields: Array<{ name: string; type: string }> }> = {
            BidAuthorization: {
                fields: [
                    { name: 'bid', type: 'Bid' },
                    { name: 'issuedAt', type: 'uint64' },
                    { name: 'expiresAt', type: 'uint64' }
                ]
            },
            ReputationRecord: {
                fields: [
                    { name: 'bidId', type: 'bytes32' },
                    { name: 'score', type: 'uint8' },
                    { name: 'comment', type: 'string' },
                    { name: 'tags', type: 'Tag[]' },
                    { name: 'nonce', type: 'bytes32' }
                ]
            },
            Bid: {
                fields: [
                    { name: 'offererId', type: 'bytes32' },
                    { name: 'requirements', type: 'Requirements' },
                    { name: 'payment', type: 'Payment' },
                    { name: 'timing', type: 'Timing' },
                    { name: 'status', type: 'Status' }
                ]
            },
            Requirements: {
                fields: [
                    { name: 'requireVerified', type: 'bool' },
                    { name: 'allowedAttestationRoots', type: 'bytes32' },
                    { name: 'allowedAgentsRoot', type: 'bytes32' },
                    { name: 'minTrustScore', type: 'uint256' }
                ]
            },
            Payment: {
                fields: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' },
                    { name: 'authorizationSig', type: 'bytes' }
                ]
            },
            Timing: {
                fields: [
                    { name: 'startTime', type: 'uint256' },
                    { name: 'endTime', type: 'uint256' },
                    { name: 'nonce', type: 'bytes32' },
                    { name: 'signature', type: 'bytes' }
                ]
            },
            Status: {
                fields: [
                    { name: 'requestHash', type: 'bytes32' },
                    { name: 'responseHash', type: 'bytes32' },
                    { name: 'completedBy', type: 'bytes32' },
                    { name: 'state', type: 'uint8' },
                    { name: 'refundPercent', type: 'uint8' }
                ]
            },
            Tag: {
                fields: [
                    { name: 'value', type: 'uint8' }
                ]
            }
        };

        return typeDefinitions[typeName] || null;
    }

    /**
     * Map Solidity type to TypeScript
     */
    private mapSolidityTypeToTS(type: string): string {
        const typeMap: Record<string, string> = {
            'address': 'string',
            'uint256': 'string',
            'uint128': 'string',
            'uint64': 'string',
            'uint32': 'string',
            'uint16': 'string',
            'uint8': 'string',
            'int256': 'string',
            'int128': 'string',
            'int64': 'string',
            'int32': 'string',
            'int16': 'string',
            'int8': 'string',
            'bool': 'boolean',
            'string': 'string',
            'bytes': 'string',
            'bytes32': 'string',
            'bytes16': 'string',
            'bytes8': 'string',
            'bytes4': 'string',
        };

        // Handle arrays
        if (type.endsWith('[]')) {
            const baseType = type.slice(0, -2);
            return `${this.mapSolidityTypeToTS(baseType)}[]`;
        }

        // Handle fixed-size arrays
        const fixedArrayMatch = type.match(/^(.+)\[(\d+)\]$/);
        if (fixedArrayMatch) {
            const baseType = fixedArrayMatch[1];
            return `${this.mapSolidityTypeToTS(baseType)}[]`;
        }

        return typeMap[type] || 'any';
    }

    /**
     * Convert to kebab-case
     */
    private toKebabCase(str: string): string {
        return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
