/**
 * TypeScript signatures generation logic
 */

import { ContractGraph } from '../../types/model';
import { SignatureItem } from '../../types/config';
import { TypeScriptTargetOptions } from '../../types/config';
import { StructExtractor, StructTypeDefinition } from './struct-extractor';

export class SignaturesGenerator {
    private outDir: string;
    private options: TypeScriptTargetOptions;

    constructor(outDir: string, options: TypeScriptTargetOptions) {
        this.outDir = outDir;
        this.options = options;
    }

    /**
     * Generate signatures package
     */
    async generateSignatures(signatureItems: SignatureItem[], graph: ContractGraph): Promise<void> {
        await this.generateDomain();
        await this.generateSignatureModules(signatureItems, graph);
        await this.generateSignaturesIndex(signatureItems);
    }

    /**
     * Generate domain.ts
     */
    private async generateDomain(): Promise<void> {
        const transport = this.options.transport || 'viem';
        const imports = this.getTransportImports(transport);

        const content = `// Auto-generated EIP-712 domain configuration
// Generated by contract-sdk-gen

${imports}

export interface EIP712Domain {
  name: string;
  version: string;
  chainId?: number;
  verifyingContract?: Address;
}

/**
 * Compute EIP-712 domain separator hash
 */
export function getDomainSeparator(
  domain: EIP712Domain,
  verifyingContract: Address,
  chainId?: number
): Hash {
  const domainData = {
    name: domain.name,
    version: domain.version,
    chainId: chainId || domain.chainId || 1,
    verifyingContract
  };
  
  return keccak256(
    encodeAbiParameters(
      [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'chainId', type: 'uint256' },
        { name: 'verifyingContract', type: 'address' }
      ],
      [domainData.name, domainData.version, BigInt(domainData.chainId), domainData.verifyingContract]
    )
  );
}
`;

        this.writeFile('src/signatures/domain.ts', content);
    }

    /**
     * Generate individual signature modules
     */
    private async generateSignatureModules(signatureItems: SignatureItem[], graph: ContractGraph): Promise<void> {
        for (const item of signatureItems) {
            const fileName = `src/signatures/${this.toKebabCase(item.primaryType)}.ts`;
            const content = this.renderSignatureModule(item, graph);
            this.writeFile(fileName, content);
        }
    }

    /**
     * Render signature module
     */
    private renderSignatureModule(item: SignatureItem, graph: ContractGraph): string {
        const structName = item.primaryType;
        const transport = this.options.transport || 'viem';
        const imports = this.getTransportImports(transport);

        // Try to extract types from contract ABI first
        let typeDefinition = null;
        let allTypes: StructTypeDefinition = {};
        const contract = graph.contracts.get(item.contract);
        if (contract) {
            const extractedTypes = StructExtractor.extractStructTypes(contract, structName);
            if (extractedTypes && extractedTypes[structName]) {
                typeDefinition = { fields: extractedTypes[structName] };
                allTypes = extractedTypes;
            }
        }

        // Fallback to hardcoded types if extraction failed
        if (!typeDefinition) {
            typeDefinition = this.getTypeDefinition(structName);
            if (typeDefinition) {
                allTypes[structName] = typeDefinition.fields;
            }
        }

        if (!typeDefinition) {
            return `// Auto-generated EIP-712 signature for ${structName}
// Generated by contract-sdk-gen

${imports}
import { EIP712Domain, getDomainSeparator } from './domain';

// Type definition not found for ${structName}
export interface ${structName} {
  // TODO: Define fields for ${structName}
}

export const ${structName.toUpperCase()}_TYPES = {
  ${structName}: [
    // TODO: Define type fields for ${structName}
  ],
} as const;

// TODO: Add hash functions when type definition is available
`;
        }

        const fields = typeDefinition.fields.map(field =>
            `  ${field.name}: ${this.mapSolidityTypeToTS(field.type)};`
        ).join('\n');

        // Generate EIP-712 types object with all dependencies
        const typesObject = this.generateTypesObject(allTypes);

        // Generate hash functions
        const hashFunctions = this.generateHashFunctions(structName, typeDefinition.fields, transport);

        // Generate domain constant from config
        const domainConstant = this.generateDomainConstant(item);

        return `// Auto-generated EIP-712 signature for ${structName}
// Generated by contract-sdk-gen

${imports}
import { EIP712Domain, getDomainSeparator } from './domain';

${domainConstant}

export interface ${structName} {
${fields}
}

${typesObject}

${hashFunctions}
`;
    }

    /**
     * Generate signatures index
     */
    private async generateSignaturesIndex(signatureItems: SignatureItem[]): Promise<void> {
        const exports = signatureItems.map(item =>
            `export * from './${this.toKebabCase(item.primaryType)}';`
        ).join('\n');

        const content = `// Auto-generated signatures barrel index
// Generated by contract-sdk-gen

export * from './domain';
${exports}
`;

        this.writeFile('src/signatures/index.ts', content);
    }

    /**
     * Get type definition for a signature type
     */
    private getTypeDefinition(typeName: string): { fields: Array<{ name: string; type: string }> } | null {
        // Hardcoded type definitions based on the contracts.yaml
        const typeDefinitions: Record<string, { fields: Array<{ name: string; type: string }> }> = {
            BidAuthorization: {
                fields: [
                    { name: 'bid', type: 'Bid' },
                    { name: 'issuedAt', type: 'uint64' },
                    { name: 'expiresAt', type: 'uint64' }
                ]
            },
            ReputationRecord: {
                fields: [
                    { name: 'bidId', type: 'bytes32' },
                    { name: 'score', type: 'uint8' },
                    { name: 'comment', type: 'string' },
                    { name: 'tags', type: 'Tag[]' },
                    { name: 'nonce', type: 'bytes32' }
                ]
            },
            Bid: {
                fields: [
                    { name: 'offererId', type: 'bytes32' },
                    { name: 'requirements', type: 'Requirements' },
                    { name: 'payment', type: 'Payment' },
                    { name: 'timing', type: 'Timing' },
                    { name: 'status', type: 'Status' }
                ]
            },
            Requirements: {
                fields: [
                    { name: 'requireVerified', type: 'bool' },
                    { name: 'allowedAttestationRoots', type: 'bytes32' },
                    { name: 'allowedAgentsRoot', type: 'bytes32' },
                    { name: 'minTrustScore', type: 'uint256' }
                ]
            },
            Payment: {
                fields: [
                    { name: 'token', type: 'address' },
                    { name: 'amount', type: 'uint256' },
                    { name: 'authorizationSig', type: 'bytes' }
                ]
            },
            Timing: {
                fields: [
                    { name: 'startTime', type: 'uint256' },
                    { name: 'endTime', type: 'uint256' },
                    { name: 'nonce', type: 'bytes32' },
                    { name: 'signature', type: 'bytes' }
                ]
            },
            Status: {
                fields: [
                    { name: 'requestHash', type: 'bytes32' },
                    { name: 'responseHash', type: 'bytes32' },
                    { name: 'completedBy', type: 'bytes32' },
                    { name: 'state', type: 'uint8' },
                    { name: 'refundPercent', type: 'uint8' }
                ]
            },
            Tag: {
                fields: [
                    { name: 'value', type: 'uint8' }
                ]
            }
        };

        return typeDefinitions[typeName] || null;
    }

    /**
     * Map Solidity type to TypeScript
     */
    private mapSolidityTypeToTS(type: string): string {
        const typeMap: Record<string, string> = {
            'address': '`0x${string}`',
            'uint256': 'bigint',
            'uint160': 'bigint',
            'uint128': 'bigint',
            'uint64': 'bigint',   // 64 bits exceeds JavaScript safe integer range (53 bits)
            'uint48': 'number',   // Fits in JavaScript number (53 bits)
            'uint32': 'number',   // Fits in JavaScript number (53 bits)
            'uint16': 'number',   // Fits in JavaScript number (53 bits)
            'uint8': 'number',    // Fits in JavaScript number (53 bits)
            'int256': 'bigint',
            'int128': 'bigint',
            'int64': 'bigint',    // 64 bits exceeds JavaScript safe integer range (53 bits)
            'int32': 'number',    // Fits in JavaScript number (53 bits)
            'int16': 'number',    // Fits in JavaScript number (53 bits)
            'int8': 'number',     // Fits in JavaScript number (53 bits)
            'bool': 'boolean',
            'string': 'string',
            'bytes': '`0x${string}`',
            'bytes32': '`0x${string}`',
            'bytes16': '`0x${string}`',
            'bytes8': '`0x${string}`',
            'bytes4': '`0x${string}`',
        };

        // Handle arrays
        if (type.endsWith('[]')) {
            const baseType = type.slice(0, -2);
            return `${this.mapSolidityTypeToTS(baseType)}[]`;
        }

        // Handle fixed-size arrays
        const fixedArrayMatch = type.match(/^(.+)\[(\d+)\]$/);
        if (fixedArrayMatch) {
            const baseType = fixedArrayMatch[1];
            return `${this.mapSolidityTypeToTS(baseType)}[]`;
        }

        return typeMap[type] || 'string'; // Default to string for unknown types
    }

    /**
     * Convert to kebab-case
     */
    private toKebabCase(str: string): string {
        return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
    }

    /**
     * Get transport-specific imports
     */
    private getTransportImports(transport: string): string {
        if (transport === 'ethers') {
            return `import { ethers } from 'ethers';`;
        }
        return `import { Address, Hash, encodeAbiParameters, keccak256, toHex, concat } from 'viem';`;
    }

    /**
     * Generate EIP-712 types object with all dependencies
     */
    private generateTypesObject(allTypes: StructTypeDefinition): string {
        const typeEntries = Object.entries(allTypes).map(([typeName, fields]) => {
            const fieldEntries = fields.map(field =>
                `    { name: '${field.name}', type: '${field.type}' }`
            ).join(',\n');
            return `  ${typeName}: [\n${fieldEntries}\n  ]`;
        }).join(',\n');

        const primaryType = Object.keys(allTypes)[0];
        return `export const ${primaryType.toUpperCase()}_TYPES = {\n${typeEntries}\n} as const;`;
    }

    /**
     * Generate EIP-712 type string
     */
    private generateTypeString(primaryType: string, allTypes: StructTypeDefinition): string {
        const typeDef = allTypes[primaryType];
        if (!typeDef) return '';

        const fieldStrings = typeDef.map(field => `${field.type} ${field.name}`).join(',');
        return `${primaryType}(${fieldStrings})`;
    }

    /**
     * Generate hash computation functions
     */
    private generateHashFunctions(structName: string, fields: Array<{ name: string; type: string }>, transport: string): string {
        const typeString = this.generateTypeString(structName, { [structName]: fields });
        const typeHashFn = this.generateTypeHashFunction(structName, typeString, transport);
        const encodeFn = this.generateEncodeFunction(structName, fields, transport);
        const signatureHashFn = this.generateSignatureHashFunction(structName, transport);

        return `${typeHashFn}\n\n${encodeFn}\n\n${signatureHashFn}`;
    }

    /**
     * Generate type hash function
     */
    private generateTypeHashFunction(structName: string, typeString: string, transport: string): string {
        if (transport === 'ethers') {
            return `/**
 * Get EIP-712 type hash for ${structName}
 */
export function get${structName}TypeHash(): string {
  return ethers.keccak256(ethers.toUtf8Bytes('${typeString}'));
}`;
        }
        return `/**
 * Get EIP-712 type hash for ${structName}
 */
export function get${structName}TypeHash(): Hash {
  return keccak256(toHex('${typeString}'));
}`;
    }

    /**
     * Generate domain constant from signature item config
     */
    private generateDomainConstant(item: SignatureItem): string {
        return `export const ${item.primaryType.toUpperCase()}_DOMAIN: EIP712Domain = {
  name: '${item.domain.name}',
  version: '${item.domain.version}'
} as const;`;
    }

    /**
     * Generate encode function
     */
    private generateEncodeFunction(structName: string, fields: Array<{ name: string; type: string }>, transport: string): string {
        const fieldTypes = fields.map(f => `{ name: '${f.name}', type: '${f.type}' }`).join(', ');

        // Generate value conversion logic
        const valueConversions = fields.map(field => {
            const tsType = this.mapSolidityTypeToTS(field.type);
            if (tsType === 'bigint') {
                return `BigInt(data.${field.name})`;
            } else if (tsType === 'number') {
                return `data.${field.name}`; // number can be passed directly to viem
            } else if (tsType === 'boolean') {
                return `data.${field.name}`;
            } else if (tsType === 'string') {
                return `data.${field.name}`;
            } else {
                // For hex string types like `0x${string}`, just pass through
                return `data.${field.name}`;
            }
        }).join(', ');

        if (transport === 'ethers') {
            return `/**
 * Encode ${structName} data for EIP-712 signature
 */
export function encode${structName}(data: ${structName}): string {
  const abiCoder = ethers.AbiCoder.defaultAbiCoder();
  const encoded = abiCoder.encode(
    ['${fields.map(f => f.type).join(',')}'],
    [${valueConversions}]
  );
  return ethers.keccak256(encoded);
}`;
        }

        return `/**
 * Encode ${structName} data for EIP-712 signature
 */
export function encode${structName}(data: ${structName}): Hash {
  return keccak256(
    encodeAbiParameters(
      [${fieldTypes}],
      [${valueConversions}]
    )
  );
}`;
    }

    /**
     * Generate signature hash function
     */
    private generateSignatureHashFunction(structName: string, transport: string): string {
        if (transport === 'ethers') {
            return `/**
 * Get complete EIP-712 signature hash for ${structName}
 */
export function get${structName}SignatureHash(
  data: ${structName},
  domain: EIP712Domain,
  verifyingContract: string,
  chainId: number
): string {
  const domainSeparator = getDomainSeparator(domain, verifyingContract, chainId);
  const structHash = encode${structName}(data);
  return ethers.keccak256(ethers.concat(['0x1901', domainSeparator, structHash]));
}`;
        }

        return `/**
 * Get complete EIP-712 signature hash for ${structName}
 */
export function get${structName}SignatureHash(
  data: ${structName},
  domain: EIP712Domain,
  verifyingContract: Address,
  chainId: number
): Hash {
  const domainSeparator = getDomainSeparator(domain, verifyingContract, chainId);
  const structHash = encode${structName}(data);
  return keccak256(concat(['0x1901', domainSeparator, structHash]));
}`;
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
