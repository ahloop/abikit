/**
 * TypeScript errors generation logic
 */

import { ContractModel, ErrorModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';
import { TypeScriptUtils } from './utils';

export class ErrorsGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate errors file for a contract
     */
    async generateErrors(contract: ContractModel): Promise<void> {
        if (contract.errors.length === 0) {
            return; // Skip if no errors
        }

        const content = this.renderErrorsTemplate(contract);
        this.writeFile(`src/contracts/${contract.name}/errors.ts`, content);
    }

    /**
     * Generate centralized error registry
     */
    async generateCentralizedErrors(contracts: ContractModel[]): Promise<void> {
        const contractsWithErrors = contracts.filter(contract =>
            contract.errors.length > 0 && !contract.isInterface
        );

        if (contractsWithErrors.length === 0) {
            return; // Skip if no contracts have errors
        }

        const content = this.renderCentralizedErrorsTemplate(contractsWithErrors);
        this.writeFile(`src/errors/index.ts`, content);
    }

    /**
     * Render per-contract errors template
     */
    private renderErrorsTemplate(contract: ContractModel): string {
        const contractName = contract.name;
        const abiName = `${contractName.toUpperCase()}_ABI`;

        // Generate error selectors
        const errorSelectors = contract.errors.map(error => {
            const canonicalSig = ErrorModel.getCanonicalSignature(error);
            const selector = this.computeErrorSelector(canonicalSig);
            const constantName = `${error.name.toUpperCase()}_ERROR_SELECTOR`;
            return `export const ${constantName} = '${selector}';`;
        }).join('\n');

        // Generate error type definitions
        const errorTypes = contract.errors.map(error => {
            const interfaceName = `${error.name}Error`;
            const fields = error.inputs.map((input, index) => {
                const tsType = TypeScriptUtils.mapSolidityTypeToTS(input, contract);
                const fieldName = input.name || `param${index}`;
                return `  ${fieldName}: ${tsType};`;
            }).join('\n');

            return `export interface ${interfaceName} {
${fields}
}`;
        }).join('\n\n');

        // Generate decode functions
        const decodeFunctions = contract.errors.map(error => {
            const interfaceName = `${error.name}Error`;
            return `export function decode${error.name}Error(data: Hex): ${interfaceName} {
  const errorAbi = ${abiName}.find(e => e.type === 'error' && e.name === '${error.name}');
  if (!errorAbi?.inputs) {
    throw new Error('Error ABI not found for ${error.name}');
  }
  
  const decoded = decodeAbiParameters(
    errorAbi.inputs,
    data.slice(10) as Hex // Remove 0x and 4-byte selector
  );
  
  const result: ${interfaceName} = {} as ${interfaceName};
  ${error.inputs.map((input, index) => {
                const fieldName = input.name || `param${index}`;
                return `result.${fieldName} = decoded[${index}] as any;`;
            }).join('\n  ')}
  
  return result;
}`;
        }).join('\n\n');

        return `// Auto-generated errors for ${contractName}
// Generated by contract-sdk-gen

import { decodeAbiParameters, type Hex, type Address, type Hash } from 'viem';
import { ${abiName} } from './abi';

// Error selectors
${errorSelectors}

// Error type definitions
${errorTypes}

// Decode functions
${decodeFunctions}
`;
    }

    /**
     * Render centralized errors template
     */
    private renderCentralizedErrorsTemplate(contracts: ContractModel[]): string {
        // Track which errors have been exported to avoid duplicates
        const exportedErrors = new Set<string>();
        const errorRegistryEntries: string[] = [];
        const errorDecoders: string[] = [];

        // Generate imports for all contract classes
        const imports = contracts.map(contract => {
            const contractName = contract.name;
            return `import { ${contractName} } from '../contracts/${contractName}';`;
        }).join('\n');

        // Process each contract and only export unique errors
        contracts.forEach(contract => {
            const contractName = contract.name;
            const contractErrors: string[] = [];
            const contractDecoders: string[] = [];

            contract.errors.forEach(error => {
                const errorKey = error.name;
                const selectorKey = `${error.name.toUpperCase()}_ERROR`;
                const decoderKey = `decode${error.name}Error`;

                if (!exportedErrors.has(errorKey)) {
                    exportedErrors.add(errorKey);
                    contractErrors.push(`  ${errorKey}: ${contractName}.${selectorKey},`);
                }

                if (!exportedErrors.has(decoderKey)) {
                    exportedErrors.add(decoderKey);
                    contractDecoders.push(`  '${error.name}': ${contractName}.${decoderKey},`);
                }
            });

            if (contractErrors.length > 0) {
                errorRegistryEntries.push(`  // From ${contractName}\n${contractErrors.join('\n')}`);
            }
            if (contractDecoders.length > 0) {
                errorDecoders.push(`  // From ${contractName}\n${contractDecoders.join('\n')}`);
            }
        });

        return `// Auto-generated centralized error registry
// Generated by contract-sdk-gen

import type { Hex } from 'viem';

// Import all contract classes
${imports}

// Combined error registry (unique errors only)
const ERROR_REGISTRY = {
${errorRegistryEntries.join('\n')}
};

// Error decoder mapping (unique decoders only)
const ERROR_DECODERS = {
${errorDecoders.join('\n')}
};

// Error selector to name mapping
const ERROR_SELECTORS: Record<string, string> = {};
const ERROR_NAMES: Record<string, string> = {};

// Populate mappings
Object.entries(ERROR_REGISTRY).forEach(([key, value]) => {
  if (key.endsWith('_ERROR') && typeof value === 'string') {
    const errorName = key.replace('_ERROR', '');
    ERROR_SELECTORS[value] = errorName;
    ERROR_NAMES[errorName] = value;
  }
});

export interface DecodedError {
  name: string;
  selector: string;
  args: any;
}

/**
 * Decode contract error from hex data
 */
export function decodeContractError(errorData: Hex): DecodedError | null {
  const selector = errorData.slice(0, 10); // 0x + 8 hex chars
  
  if (!(selector in ERROR_SELECTORS)) {
    return null;
  }
  
  const errorName = ERROR_SELECTORS[selector];
  const decoder = ERROR_DECODERS[errorName as keyof typeof ERROR_DECODERS];
  
  if (!decoder || typeof decoder !== 'function') {
    return null;
  }
  
  try {
    const args = decoder(errorData);
    return {
      name: errorName!,
      selector,
      args,
    };
  } catch (error) {
    console.warn(\`Failed to decode error \${errorName}:\`, error);
    return null;
  }
}

/**
 * Get error selector by name
 */
export function getErrorSelector(errorName: string): string | undefined {
  return ERROR_NAMES[errorName];
}

/**
 * Get error name by selector
 */
export function getErrorName(selector: string): string | undefined {
  return ERROR_SELECTORS[selector];
}

/**
 * Check if an error selector is known
 */
export function isKnownError(selector: string): boolean {
  return selector in ERROR_SELECTORS;
}

// Note: Errors are now embedded as static members of contract classes
// Access them like: MockERC20.INSUFFICIENT_FUNDS_ERROR, MockERC20.decodeInsufficientFundsError(data)
`;
    }

    /**
     * Compute error selector (first 4 bytes of keccak256 hash of canonical signature)
     */
    private computeErrorSelector(canonicalSignature: string): string {
        // This is a simplified implementation - in practice, you'd use a proper keccak256 library
        const hash = this.simpleKeccak256(canonicalSignature);
        return `0x${hash.slice(0, 8)}`; // First 4 bytes (8 hex characters)
    }

    /**
     * Simple keccak256 implementation for generation time
     * In a real implementation, this would use a proper keccak256 library
     */
    private simpleKeccak256(input: string): string {
        // This is a placeholder implementation
        // In practice, you'd use a proper keccak256 library like 'js-sha3' or 'ethers'
        const crypto = require('crypto');
        const hash = crypto.createHash('sha3-256');
        hash.update(input);
        return hash.digest('hex');
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
