/**
 * TypeScript contract generation logic
 */

import { ContractModel, FunctionModel, EventModel, ErrorModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';
import { TypeScriptUtils } from './utils';

export class ContractGenerator {
  private outDir: string;
  private options: TypeScriptTargetOptions;

  constructor(outDir: string, _options: TypeScriptTargetOptions) {
    this.outDir = outDir;
    this.options = _options;
  }

  /**
   * Generate contract module
   */
  async generateContract(contract: ContractModel): Promise<void> {
    const contractName = contract.name;

    // Generate ABI file
    const abiContent = this.renderAbiTemplate(contract);
    this.writeFile(`src/contracts/${contractName}/abi.ts`, abiContent);

    // Generate contract wrapper
    const contractContent = this.renderContractTemplate(contract);
    this.writeFile(`src/contracts/${contractName}/contract.ts`, contractContent);

    // Generate contract-specific types (only if contract has unique types)
    const uniqueTypes = this.getUniqueTypes(contract);
    if (uniqueTypes.length > 0) {
      const typesContent = this.renderContractTypesTemplate(contract, uniqueTypes);
      this.writeFile(`src/contracts/${contractName}/types.ts`, typesContent);
    }

    // Generate barrel index
    const indexContent = this.renderContractIndexTemplate(contract, uniqueTypes.length > 0);
    this.writeFile(`src/contracts/${contractName}/index.ts`, indexContent);
  }

  /**
   * Render ABI file
   */
  private renderAbiTemplate(contract: ContractModel): string {
    return `// Auto-generated ABI for ${contract.name}
// Generated by contract-sdk-gen

export const ${contract.name.toUpperCase()}_ABI = ${JSON.stringify(contract.abi, null, 2)} as const;
`;
  }

  /**
   * Get unique types for a contract (not in common/types)
   */
  private getUniqueTypes(_contract: ContractModel): any[] {
    // For now, return empty - all structs go to common/types
    // In the future, this could detect contract-specific types
    return [];
  }

  /**
   * Render contract-specific types file
   */
  private renderContractTypesTemplate(contract: ContractModel, _uniqueTypes: any[]): string {
    return `// Auto-generated types for ${contract.name}
// Generated by contract-sdk-gen

// Contract-specific types (not in common/types)
// Currently empty - all shared types are in common/types.ts
`;
  }

  /**
   * Render contract barrel index
   */
  private renderContractIndexTemplate(contract: ContractModel, hasTypes: boolean): string {
    const typeExports = hasTypes ? `export * from './types';` : '';

    return `// Auto-generated barrel index for ${contract.name}
// Generated by contract-sdk-gen

export { ${contract.name} } from './contract';
export type { ${contract.name}Config } from './contract';
export { ${contract.name.toUpperCase()}_ABI } from './abi';
${typeExports}

// Note: Events, selectors, and errors are now embedded as static members of the ${contract.name} class
// Access them like: ${contract.name}.APPROVAL_EVENT_SIGNATURE, ${contract.name}.APPROVE_SELECTOR, etc.
`;
  }

  /**
   * Render contract template
   */
  private renderContractTemplate(contract: ContractModel): string {
    const usesAddress = TypeScriptUtils.contractUsesType(contract, 'address');
    const usesBytes32 = TypeScriptUtils.contractUsesType(contract, 'bytes32');
    const usesBytes = TypeScriptUtils.contractUsesType(contract, 'bytes');

    const viemTypes: string[] = ['Hash']; // Always need Hash for write functions
    if (usesAddress) viemTypes.push('Address');
    if (usesBytes32 && !viemTypes.includes('Hash')) viemTypes.push('Hash');
    if (usesBytes) viemTypes.push('Hex');

    // Always need Address for the address field in config interface
    if (!viemTypes.includes('Address')) viemTypes.push('Address');

    const viemImport = viemTypes.length > 0
      ? `import type { ${viemTypes.join(', ')} } from 'viem';`
      : '';

    const hasStructs = contract.structs.length > 0;

    const typeNames: string[] = [];
    if (hasStructs) {
      typeNames.push(...contract.structs.map(s => s.name));
    }
    // PreparedTransaction is needed whenever we emit prepare hooks for write functions
    const hasWriteFunctions = contract.functions.some(func =>
      func.stateMutability === 'nonpayable' || func.stateMutability === 'payable'
    );
    const emitPrepareHooks = this.options.emitPrepareHooks !== false && hasWriteFunctions;
    if (emitPrepareHooks) {
      typeNames.push('PreparedTransaction');
    }

    const typesImport = typeNames.length > 0
      ? `import type { ${typeNames.join(', ')} } from '../../types';`
      : '';

    return `// Auto-generated contract wrapper for ${contract.name}
// Generated by contract-sdk-gen

import { readContract, writeContract, sendTransaction } from 'viem/actions';
import { encodeFunctionData } from 'viem';
import type { PublicClient, WalletClient } from 'viem';
${viemImport}
${typesImport}
import { ${contract.name.toUpperCase()}_ABI } from './abi';

export interface ${contract.name}Config {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class ${contract.name} {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: ${contract.name}Config) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

${this.renderStaticEventSignatures(contract)}

${this.renderStaticSelectors(contract)}

${this.renderStaticErrors(contract)}

${contract.functions.filter((func, index, arr) => arr.findIndex(f => f.name === func.name) === index).map(func => this.renderFunctionMethod(func, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventLogsMethod(event, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventMethod(event, contract)).join('\n\n')}
}
`;
  }

  /**
   * Render function method
   */
  private renderFunctionMethod(func: FunctionModel, contract: ContractModel): string {
    const params = func.inputs.map((input, idx) =>
      `${input.name || `arg${idx}`}: ${TypeScriptUtils.mapSolidityTypeToTS(input, contract)}`
    ).join(', ');

    const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
    const returnType = isReadOnly
      ? (func.outputs.length === 0
        ? 'void'
        : func.outputs.length === 1
          ? TypeScriptUtils.mapSolidityTypeToTS(func.outputs[0], contract)
          : `[${func.outputs.map(o => TypeScriptUtils.mapSolidityTypeToTS(o, contract)).join(', ')}]`)
      : 'Hash';

    const argsArray = func.inputs.length > 0 ? `[${func.inputs.map((i, idx) => i.name || `arg${idx}`).join(', ')}]` : '[]';
    const argsWithTypeAssertion = func.inputs.length > 0 ? `${argsArray} as any` : argsArray;

    const emitPrepareHooks = this.options.emitPrepareHooks !== false;

    // Read-only functions remain unchanged
    if (isReadOnly || !emitPrepareHooks) {
      return `  /**
   * ${func.name}
   * ${func.stateMutability}
   */
  async ${func.name}(${params}): Promise<${returnType}> {
    ${isReadOnly
        ? `if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
    }) as ${returnType};`
        : `if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });`
      }
  }`;
    }

    // For write functions with prepare hooks, generate a prepare method plus the write method
    const capitalizedName = func.name.charAt(0).toUpperCase() + func.name.slice(1);
    const prepareMethodName = `prepare${capitalizedName}`;
    const paramNames = func.inputs.map((input, idx) => input.name || `arg${idx}`).join(', ');

    const prepareMethod = `  /**
   * ${prepareMethodName}
   * Prepares transaction data for ${func.name} without sending it.
   */
  ${prepareMethodName}(${params}): PreparedTransaction {
    const calldata = encodeFunctionData({
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
    });
    return {
      to: this.address,
      data: calldata,
      value: 0n,
    };
  }`;

    const writeMethod = `  /**
   * ${func.name}
   * ${func.stateMutability}
   */
  async ${func.name}(${params}): Promise<${returnType}> {
    if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    const prepared = this.${prepareMethodName}(${paramNames});
    return await sendTransaction(this.walletClient, {
      to: prepared.to,
      data: prepared.data,
      value: prepared.value,
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });
  }`;

    return `${prepareMethod}

${writeMethod}`;
  }

  /**
   * Render event method
   */
  private renderEventMethod(event: EventModel, contract: ContractModel): string {
    return `  /**
   * Watch ${event.name} events
   */
  watch${event.name}(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      eventName: '${event.name}',
      onLogs,
    });
  }`;
  }

  /**
   * Render event logs method
   */
  private renderEventLogsMethod(event: EventModel, contract: ContractModel): string {
    const indexedParams = event.inputs.filter(p => p.indexed);
    const params = indexedParams.map(p =>
      `${p.name}?: ${TypeScriptUtils.mapSolidityTypeToTS(p, contract)}`
    ).join(', ');

    const argsFilter = indexedParams.length > 0
      ? `args: { ${indexedParams.map(p => `${p.name}: options?.${p.name}`).join(', ')} }`
      : '';

    return `  /**
   * Get ${event.name} event logs
   */
  async get${event.name}Logs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    ${params ? params + ';' : ''}
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ${contract.name.toUpperCase()}_ABI.find(e => e.type === 'event' && e.name === '${event.name}'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      ${argsFilter}
    }) as any[];
  }`;
  }

  /**
   * Render static event signatures and helpers
   */
  private renderStaticEventSignatures(contract: ContractModel): string {
    if (contract.events.length === 0) return '';

    const eventSignatures = contract.events.map(event => {
      const signature = EventModel.getCanonicalSignature(event);
      const eventSignature = `0x${require('crypto').createHash('sha3-256').update(signature).digest('hex')}`;

      return `  // Event: ${event.name}
  static readonly ${event.name.toUpperCase()}_EVENT_SIGNATURE = '${eventSignature}';`;
    }).join('\n\n');

    const eventHelpers = contract.events.map(event => {
      return `  /**
   * Check if logs contain ${event.name} event
   */
  static has${event.name}Event(logs: any[]): boolean {
    return logs.some(log => log.topics?.[0] === ${contract.name}.${event.name.toUpperCase()}_EVENT_SIGNATURE);
  }

  /**
   * Find ${event.name} events in logs
   */
  static find${event.name}Events(logs: any[]): any[] {
    return logs.filter(log => log.topics?.[0] === ${contract.name}.${event.name.toUpperCase()}_EVENT_SIGNATURE);
  }`;
    }).join('\n\n');

    return `${eventSignatures}

${eventHelpers}`;
  }

  /**
   * Render static function selectors
   */
  private renderStaticSelectors(contract: ContractModel): string {
    const functionsWithSelectors = contract.functions.filter(func =>
      ['pure', 'view', 'nonpayable', 'payable'].includes(func.stateMutability)
    );

    if (functionsWithSelectors.length === 0) return '';

    // Group functions by name to handle overloading
    const functionGroups = new Map<string, FunctionModel[]>();
    functionsWithSelectors.forEach(func => {
      if (!functionGroups.has(func.name)) {
        functionGroups.set(func.name, []);
      }
      functionGroups.get(func.name)!.push(func);
    });

    const selectorConstants = functionsWithSelectors.map(func => {
      const signature = FunctionModel.getCanonicalSignature(func);
      const selector = `0x${require('crypto').createHash('sha3-256').update(signature).digest('hex').slice(0, 8)}`;

      // Create unique name for overloaded functions
      const functionGroup = functionGroups.get(func.name)!;
      const isOverloaded = functionGroup.length > 1;
      const uniqueName = isOverloaded
        ? `${func.name}_${this.getSignatureHash(signature)}`
        : func.name;

      return `  // Function: ${func.name}${isOverloaded ? ` (${signature})` : ''}
  static readonly ${uniqueName.toUpperCase()}_SELECTOR = '${selector}';`;
    }).join('\n\n');

    const selectorMappings = `  // Function selector mappings
  static readonly SELECTORS = {
${functionsWithSelectors.map(func => {
      const signature = FunctionModel.getCanonicalSignature(func);
      const functionGroup = functionGroups.get(func.name)!;
      const isOverloaded = functionGroup.length > 1;
      const uniqueName = isOverloaded
        ? `${func.name}_${this.getSignatureHash(signature)}`
        : func.name;
      return `    ${uniqueName}: ${contract.name}.${uniqueName.toUpperCase()}_SELECTOR`;
    }).join(',\n')}
  };

  static readonly SELECTOR_TO_FUNCTION = {
${functionsWithSelectors.map(func => {
      const signature = FunctionModel.getCanonicalSignature(func);
      const selector = `0x${require('crypto').createHash('sha3-256').update(signature).digest('hex').slice(0, 8)}`;
      const functionGroup = functionGroups.get(func.name)!;
      const isOverloaded = functionGroup.length > 1;
      const uniqueName = isOverloaded
        ? `${func.name}_${this.getSignatureHash(signature)}`
        : func.name;
      return `    '${selector}': '${uniqueName}'`;
    }).join(',\n')}
  };`;

    const selectorHelpers = `  /**
   * Get function selector by name
   */
  static getFunctionSelector(functionName: string): string | undefined {
    return ${contract.name}.SELECTORS[functionName as keyof typeof ${contract.name}.SELECTORS];
  }

  /**
   * Get function name by selector
   */
  static getFunctionName(selector: string): string | undefined {
    return ${contract.name}.SELECTOR_TO_FUNCTION[selector as keyof typeof ${contract.name}.SELECTOR_TO_FUNCTION];
  }`;

    return `${selectorConstants}

${selectorMappings}

${selectorHelpers}`;
  }

  /**
   * Get a short hash of the signature for unique naming
   */
  private getSignatureHash(signature: string): string {
    return require('crypto').createHash('sha3-256').update(signature).digest('hex').slice(0, 8);
  }

  /**
   * Render static error selectors and decoders
   */
  private renderStaticErrors(contract: ContractModel): string {
    if (contract.errors.length === 0) return '';

    const errorConstants = contract.errors.map(error => {
      const signature = ErrorModel.getCanonicalSignature(error);
      const errorSelector = `0x${require('crypto').createHash('sha3-256').update(signature).digest('hex').slice(0, 8)}`;

      return `  // Error: ${error.name}
  static readonly ${error.name.toUpperCase()}_ERROR = '${errorSelector}';`;
    }).join('\n\n');

    const errorDecoders = contract.errors.map(error => {
      const decodeAssignments = error.inputs.map((input, index) => {
        const fieldName = input.name || `param${index}`;
        return `    result.${fieldName} = decoded[${index}];`;
      }).join('\n');

      const resultType = error.inputs.length === 0
        ? 'Record<string, never>'
        : `{ ${error.inputs.map((input, index) => {
          const fieldName = input.name || `param${index}`;
          return `${fieldName}: ${TypeScriptUtils.mapSolidityTypeToTS(input, contract)}`;
        }).join('; ')} }`;

      return `  /**
   * Decode ${error.name} error
   */
  static decode${error.name}Error(data: string): ${resultType} {
    const decoded = require('viem').decodeAbiParameters(
      ${contract.name.toUpperCase()}_ABI.find(e => e.type === 'error' && e.name === '${error.name}')?.inputs || [],
      data.slice(10) // Remove 0x and 4-byte selector
    );

    const result = {} as ${resultType};
${decodeAssignments}

    return result;
  }`;
    }).join('\n\n');

    return `${errorConstants}

${errorDecoders}`;
  }


  /**
   * Write file helper
   */
  private writeFile(relativePath: string, content: string): void {
    const fs = require('fs');
    const path = require('path');
    const fullPath = path.join(this.outDir, relativePath);
    const dir = path.dirname(fullPath);

    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(fullPath, content);
  }
}
