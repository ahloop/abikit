/**
 * TypeScript interface generation logic
 */

import { ContractModel, FunctionModel, EventModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';
import { TypeScriptUtils } from './utils';

export class InterfaceGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate interface module
     */
    async generateInterface(contract: ContractModel): Promise<void> {
        const interfaceName = contract.name;

        // Generate ABI file
        const abiContent = this.renderAbiTemplate(contract);
        this.writeFile(`src/interfaces/${interfaceName}/abi.ts`, abiContent);

        // Generate interface wrapper
        const interfaceContent = this.renderInterfaceTemplate(contract);
        this.writeFile(`src/interfaces/${interfaceName}/interface.ts`, interfaceContent);

        // Generate interface-specific types (only if interface has unique types)
        const uniqueTypes = this.getUniqueTypes(contract);
        if (uniqueTypes.length > 0) {
            const typesContent = this.renderInterfaceTypesTemplate(contract, uniqueTypes);
            this.writeFile(`src/interfaces/${interfaceName}/types.ts`, typesContent);
        }

        // Generate barrel index
        const indexContent = this.renderInterfaceIndexTemplate(contract, uniqueTypes.length > 0);
        this.writeFile(`src/interfaces/${interfaceName}/index.ts`, indexContent);
    }

    /**
     * Render ABI file
     */
    private renderAbiTemplate(contract: ContractModel): string {
        return `// Auto-generated ABI for ${contract.name}
// Generated by contract-sdk-gen

export const ${contract.name.toUpperCase()}_ABI = ${JSON.stringify(contract.abi, null, 2)} as const;
`;
    }

    /**
     * Get unique types for an interface (not in common/types)
     */
    private getUniqueTypes(_contract: ContractModel): any[] {
        // For now, return empty - all structs go to common/types
        // In the future, this could detect interface-specific types
        return [];
    }

    /**
     * Render interface-specific types file
     */
    private renderInterfaceTypesTemplate(contract: ContractModel, _uniqueTypes: any[]): string {
        return `// Auto-generated types for ${contract.name}
// Generated by contract-sdk-gen

// Interface-specific types (not in common/types)
// Currently empty - all shared types are in common/types.ts
`;
    }

    /**
     * Render interface barrel index
     */
    private renderInterfaceIndexTemplate(contract: ContractModel, hasTypes: boolean): string {
        const typeExports = hasTypes ? `export * from './types';` : '';

        return `// Auto-generated barrel index for ${contract.name}
// Generated by contract-sdk-gen

export { ${contract.name} } from './interface';
export type { ${contract.name}Config } from './interface';
export { ${contract.name.toUpperCase()}_ABI } from './abi';
${typeExports}
`;
    }

    /**
     * Render interface template
     */
    private renderInterfaceTemplate(contract: ContractModel): string {
        const usesAddress = TypeScriptUtils.contractUsesType(contract, 'address');
        const usesBytes32 = TypeScriptUtils.contractUsesType(contract, 'bytes32');
        const usesBytes = TypeScriptUtils.contractUsesType(contract, 'bytes');

        const viemTypes: string[] = ['Hash']; // Always need Hash for write functions
        if (usesAddress) viemTypes.push('Address');
        if (usesBytes32 && !viemTypes.includes('Hash')) viemTypes.push('Hash');
        if (usesBytes) viemTypes.push('Hex');

        // Always need Address for the address field in config interface
        if (!viemTypes.includes('Address')) viemTypes.push('Address');

        const viemImport = viemTypes.length > 0
            ? `import type { ${viemTypes.join(', ')} } from 'viem';`
            : '';

        const hasStructs = contract.structs.length > 0;
        const typesImport = hasStructs
            ? `import type { ${contract.structs.map(s => s.name).join(', ')} } from '../../types';`
            : '';

        return `// Auto-generated interface wrapper for ${contract.name}
// Generated by contract-sdk-gen

import { readContract, writeContract } from 'viem/actions';
import type { PublicClient, WalletClient } from 'viem';
${viemImport}
${typesImport}
import { ${contract.name.toUpperCase()}_ABI } from './abi';

export interface ${contract.name}Config {
  address: Address;
  publicClient?: PublicClient;
  walletClient?: WalletClient;
}

export class ${contract.name} {
  public readonly address: Address;
  private publicClient?: PublicClient;
  private walletClient?: WalletClient;

  constructor(config: ${contract.name}Config) {
    this.address = config.address;
    this.publicClient = config.publicClient;
    this.walletClient = config.walletClient;
  }

${contract.functions.filter((func, index, arr) => arr.findIndex(f => f.name === func.name) === index).map(func => this.renderFunctionMethod(func, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventLogsMethod(event, contract)).join('\n\n')}

${contract.events.map(event => this.renderEventMethod(event, contract)).join('\n\n')}
}
`;
    }

    /**
     * Render function method
     */
    private renderFunctionMethod(func: FunctionModel, contract: ContractModel): string {
        const params = func.inputs.map((input, idx) =>
            `${input.name || `arg${idx}`}: ${TypeScriptUtils.mapSolidityTypeToTS(input, contract)}`
        ).join(', ');

        const isReadOnly = func.stateMutability === 'view' || func.stateMutability === 'pure';
        const returnType = isReadOnly
            ? (func.outputs.length === 0
                ? 'void'
                : func.outputs.length === 1
                    ? TypeScriptUtils.mapSolidityTypeToTS(func.outputs[0], contract)
                    : `[${func.outputs.map(o => TypeScriptUtils.mapSolidityTypeToTS(o, contract)).join(', ')}]`)
            : 'Hash';

        const argsArray = func.inputs.length > 0 ? `[${func.inputs.map((i, idx) => i.name || `arg${idx}`).join(', ')}]` : '[]';
        const argsWithTypeAssertion = func.inputs.length > 0 ? `${argsArray} as any` : argsArray;

        return `  /**
   * ${func.name}
   * ${func.stateMutability}
   */
  async ${func.name}(${params}): Promise<${returnType}> {
    ${isReadOnly
                ? `if (!this.publicClient) throw new Error('Public client required for read operations');
    return await readContract(this.publicClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
    }) as ${returnType};`
                : `if (!this.walletClient) throw new Error('Wallet client required for write operations');
    if (!this.walletClient.account) throw new Error('Wallet client account required for write operations');
    return await writeContract(this.walletClient, {
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      functionName: '${func.name}',
      args: ${argsWithTypeAssertion},
      account: this.walletClient.account,
      chain: this.walletClient.chain,
    });`
            }
  }`;
    }

    /**
     * Render event method
     */
    private renderEventMethod(event: EventModel, contract: ContractModel): string {
        return `  /**
   * Watch ${event.name} events
   */
  watch${event.name}(onLogs: (logs: any[]) => void) {
    if (!this.publicClient) throw new Error('Public client required for event watching');
    // Event watching implementation using watchContractEvent
    return this.publicClient.watchContractEvent({
      address: this.address,
      abi: ${contract.name.toUpperCase()}_ABI,
      eventName: '${event.name}',
      onLogs,
    });
  }`;
    }

    /**
     * Render event logs method
     */
    private renderEventLogsMethod(event: EventModel, contract: ContractModel): string {
        const indexedParams = event.inputs.filter(p => p.indexed);
        const params = indexedParams.map(p =>
            `${p.name}?: ${TypeScriptUtils.mapSolidityTypeToTS(p, contract)}`
        ).join(', ');

        const argsFilter = indexedParams.length > 0
            ? `args: { ${indexedParams.map(p => `${p.name}: options?.${p.name}`).join(', ')} }`
            : '';

        return `  /**
   * Get ${event.name} event logs
   */
  async get${event.name}Logs(options?: {
    fromBlock?: bigint;
    toBlock?: bigint;
    ${params ? params + ';' : ''}
  }): Promise<any[]> {
    if (!this.publicClient) throw new Error('Public client required for reading logs');
    return await this.publicClient.getLogs({
      address: this.address,
      event: ${contract.name.toUpperCase()}_ABI.find(e => e.type === 'event' && e.name === '${event.name}'),
      fromBlock: options?.fromBlock ?? 0n,
      toBlock: options?.toBlock ?? 'latest',
      ${argsFilter}
    }) as any[];
  }`;
    }


    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
