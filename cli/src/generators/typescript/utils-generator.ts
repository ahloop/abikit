/**
 * Utilities generator for TypeScript SDK
 * Generates generic blockchain utilities and contract helper functions
 */

import { BaseGenerator } from '../base';
import { TypeScriptTargetOptions } from '../../types/config';

export class UtilitiesGenerator extends BaseGenerator {
    protected options: TypeScriptTargetOptions;

    constructor(outDir: string, options: TypeScriptTargetOptions) {
        super(outDir, options);
        this.options = options;
    }

    getName(): string {
        return 'Utilities Generator';
    }

    async generate(): Promise<void> {
        // This method is required by BaseGenerator but not used
        // We call generateUtilities() directly instead
    }

    validateOptions(): void {
        // No validation needed for utilities generation
    }

    /**
     * Generate all utility files
     */
    generateUtilities(): void {
        this.generateBlockchainUtilities();
        this.generateContractHelpers();
        this.generateEventUtilities();
        this.generateCreate2Utilities();
        this.generateUtilsIndex();
    }

    /**
     * Generate generic blockchain utilities
     */
    private generateBlockchainUtilities(): void {
        const content = `/**
 * Generic blockchain utilities for viem
 * Auto-generated by ABIKIT
 */

import {
    stringToBytes,
    bytesToString,
    parseEther,
    formatEther,
    isAddress,
    getAddress as getChecksumAddress,
    formatUnits,
    parseUnits,
    createPublicClient,
    createWalletClient,
    http,
    type PublicClient,
    type WalletClient,
    type Address,
    type Hash,
    type TransactionReceipt,
    type Hex
} from 'viem';

/**
 * Convert a string to bytes32 format
 */
export function toBytes32(str: string): Hex {
    return stringToBytes(str, { size: 32 }) as unknown as Hex;
}

/**
 * Convert bytes32 to string
 */
export function fromBytes32(bytes32: Hex): string {
    return bytesToString(bytes32 as any);
}

/**
 * Convert ETH to Wei
 */
export function toWei(amount: string | number): bigint {
    return parseEther(amount.toString());
}

/**
 * Convert Wei to ETH
 */
export function fromWei(amount: string | number | bigint): string {
    return formatEther(BigInt(amount.toString()));
}

/**
 * Convert a number to hex string
 */
export function toHex(num: number): Hex {
    return \`0x\${num.toString(16)}\` as Hex;
}

/**
 * Check if an address is valid
 */
export function isValidAddress(address: string): boolean {
    return isAddress(address);
}

/**
 * Get the checksummed version of an address
 */
export function getAddress(address: string): Address {
    return getChecksumAddress(address);
}

/**
 * Format a number to a specific number of decimal places
 */
export function formatNumber(num: string | number | bigint, decimals: number = 18): string {
    return formatUnits(BigInt(num.toString()), decimals);
}

/**
 * Parse a number string with specific decimal places
 */
export function parseNumber(num: string, decimals: number = 18): bigint {
    return parseUnits(num, decimals);
}

/**
 * Convert a string to a specific number of bytes
 */
export function toBytes(str: string, size?: number): Hex {
    return stringToBytes(str, { size }) as unknown as Hex;
}

/**
 * Convert bytes to string
 */
export function fromBytes(bytes: Hex): string {
    return bytesToString(bytes as any);
}

/**
 * Check if a value is a valid hex string
 */
export function isHex(value: string): boolean {
    return /^0x[0-9a-fA-F]*$/.test(value);
}

/**
 * Pad a hex string to a specific length
 */
export function padHex(hex: string, length: number): Hex {
    const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
    const padded = cleanHex.padStart(length, '0');
    return \`0x\${padded}\` as Hex;
}

/**
 * Slice a hex string to a specific length
 */
export function sliceHex(hex: string, start: number, end?: number): Hex {
    const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
    const sliced = cleanHex.slice(start * 2, end ? end * 2 : undefined);
    return \`0x\${sliced}\` as Hex;
}

/**
 * Wait for a transaction to be mined
 */
export async function waitForTransaction(
    client: PublicClient,
    txHash: Hash,
    confirmations: number = 1
): Promise<TransactionReceipt> {
    return await client.waitForTransactionReceipt({
        hash: txHash,
        confirmations: Number(confirmations)
    });
}

/**
 * Get the current block number
 */
export async function getCurrentBlockNumber(client: PublicClient): Promise<bigint> {
    return await client.getBlockNumber();
}

/**
 * Get the current gas price
 */
export async function getGasPrice(client: PublicClient): Promise<bigint> {
    return await client.getGasPrice();
}

/**
 * Estimate gas for a transaction
 */
export async function estimateGas(
    client: PublicClient,
    transaction: {
        to?: Address;
        data?: Hex;
        value?: bigint;
        from?: Address;
    }
): Promise<bigint> {
    return await client.estimateGas(transaction);
}

/**
 * Create a public client for read operations
 */
export function createPublicClientFromRpc(rpcUrl: string): PublicClient {
    return createPublicClient({
        transport: http(rpcUrl),
    });
}

/**
 * Create a wallet client for write operations
 */
export function createWalletClientFromPrivateKey(
    privateKey: Hex,
    rpcUrl: string
): WalletClient {
    return createWalletClient({
        transport: http(rpcUrl),
        account: privateKey,
    });
}

/**
 * Get the balance of an address
 */
export async function getBalance(
    client: PublicClient,
    address: Address
): Promise<bigint> {
    return await client.getBalance({ address });
}

/**
 * Get the nonce of an address
 */
export async function getNonce(
    client: PublicClient,
    address: Address
): Promise<number> {
    return await client.getTransactionCount({ address });
}

/**
 * Check if a contract exists at the given address
 */
export async function contractExists(
    client: PublicClient,
    address: Address
): Promise<boolean> {
    const code = await client.getCode({ address });
    return code !== '0x';
}
`;

        this.writeFile('src/utils/blockchain.ts', content);
    }

    /**
     * Generate contract helper utilities
     */
    private generateContractHelpers(): void {
        const content = `/**
 * Contract helper utilities that leverage the generated class-based features
 * Auto-generated by ABIKIT
 */

import type { Address, Hash, Hex } from 'viem';

/**
 * Contract class interface for type safety
 */
export interface ContractWithStaticMembers {
    [key: string]: any;
    getFunctionSelector?(functionName: string): string | undefined;
    getFunctionName?(selector: string): string | undefined;
    SELECTORS?: Record<string, string>;
    SELECTOR_TO_FUNCTION?: Record<string, string>;
}

/**
 * Create an event filter using the contract's embedded event signature
 */
export function createEventFilter(
    contract: ContractWithStaticMembers,
    eventName: string,
    options: {
        fromBlock?: bigint;
        toBlock?: bigint;
        address?: Address;
        topics?: (string | string[])[];
    } = {}
) {
    const signatureKey = \`\${eventName.toUpperCase()}_EVENT_SIGNATURE\`;
    const signature = contract[signatureKey];

    if (!signature) {
        throw new Error(\`Event signature not found for \${eventName} in contract\`);
    }

    return {
        address: options.address,
        topics: [signature, ...(options.topics || [])],
        fromBlock: options.fromBlock,
        toBlock: options.toBlock
    };
}

/**
 * Get function selector for a given function name
 */
export function getFunctionSelector(
    contract: ContractWithStaticMembers,
    functionName: string
): string | undefined {
    // Try the helper method first
    if (contract.getFunctionSelector) {
        return contract.getFunctionSelector(functionName);
    }

    // Fall back to SELECTORS object
    if (contract.SELECTORS) {
        return contract.SELECTORS[functionName];
    }

    return undefined;
}

/**
 * Get function name for a given selector
 */
export function getFunctionName(
    contract: ContractWithStaticMembers,
    selector: string
): string | undefined {
    // Try the helper method first
    if (contract.getFunctionName) {
        return contract.getFunctionName(selector);
    }

    // Fall back to SELECTOR_TO_FUNCTION object
    if (contract.SELECTOR_TO_FUNCTION) {
        return contract.SELECTOR_TO_FUNCTION[selector];
    }

    return undefined;
}

/**
 * Check if a contract has a specific event in logs
 */
export function hasContractEvent(
    contract: ContractWithStaticMembers,
    eventName: string,
    logs: any[]
): boolean {
    const helperName = \`has\${eventName}Event\`;
    if (typeof contract[helperName] === 'function') {
        return contract[helperName](logs);
    }
    return false;
}

/**
 * Find specific events in logs using contract's helper method
 */
export function findContractEvents(
    contract: ContractWithStaticMembers,
    eventName: string,
    logs: any[]
): any[] {
    const helperName = \`find\${eventName}Events\`;
    if (typeof contract[helperName] === 'function') {
        return contract[helperName](logs);
    }
    return [];
}

/**
 * Get all available event signatures for a contract
 */
export function getContractEventSignatures(contract: ContractWithStaticMembers): Record<string, string> {
    const signatures: Record<string, string> = {};

    // Find all properties ending with _EVENT_SIGNATURE
    for (const key in contract) {
        if (key.endsWith('_EVENT_SIGNATURE')) {
            const eventName = key.replace('_EVENT_SIGNATURE', '').toLowerCase();
            signatures[eventName] = contract[key];
        }
    }

    return signatures;
}

/**
 * Get all available function selectors for a contract
 */
export function getContractFunctionSelectors(contract: ContractWithStaticMembers): Record<string, string> {
    if (contract.SELECTORS) {
        return { ...contract.SELECTORS };
    }

    // Fall back to finding individual selector constants
    const selectors: Record<string, string> = {};
    for (const key in contract) {
        if (key.endsWith('_SELECTOR')) {
            const functionName = key.replace('_SELECTOR', '').toLowerCase();
            selectors[functionName] = contract[key];
        }
    }

    return selectors;
}

/**
 * Get all available error selectors for a contract
 */
export function getContractErrorSelectors(contract: ContractWithStaticMembers): Record<string, string> {
    const errors: Record<string, string> = {};

    // Find all properties ending with _ERROR
    for (const key in contract) {
        if (key.endsWith('_ERROR')) {
            const errorName = key.replace('_ERROR', '');
            errors[errorName] = contract[key];
        }
    }

    return errors;
}

/**
 * Decode an error using the contract's error decoders
 */
export function decodeContractErrorFromContract(
    contract: ContractWithStaticMembers,
    errorData: string
): { success: boolean; errorName?: string; data?: any; decoder?: string } {
    // Get all error decoders
    const errorDecoders: string[] = [];
    for (const key in contract) {
        if (key.startsWith('decode') && key.endsWith('Error') && typeof contract[key] === 'function') {
            errorDecoders.push(key);
        }
    }

    // Try each decoder
    for (const decoderName of errorDecoders) {
        try {
            const decoded = contract[decoderName](errorData);
            const errorName = decoderName.replace('decode', '').replace('Error', '');
            return {
                success: true,
                errorName,
                data: decoded,
                decoder: decoderName
            };
        } catch (error) {
            // Continue to next decoder
        }
    }

    return { success: false };
}

/**
 * Analyze transaction logs for events from multiple contracts
 */
export function analyzeTransactionLogs(
    contracts: ContractWithStaticMembers[],
    logs: any[]
): Record<string, { hasEvent: boolean; events: any[] }> {
    const analysis: Record<string, { hasEvent: boolean; events: any[] }> = {};

    for (const contract of contracts) {
        const contractName = contract.constructor.name;
        const eventSignatures = getContractEventSignatures(contract);

        analysis[contractName] = { hasEvent: false, events: [] };

        for (const eventName of Object.keys(eventSignatures)) {
            const hasEvent = hasContractEvent(contract, eventName, logs);
            const events = findContractEvents(contract, eventName, logs);

            if (hasEvent) {
                analysis[contractName].hasEvent = true;
                analysis[contractName].events.push(...events);
            }
        }
    }

    return analysis;
}

/**
 * Validate function call data against contract selectors
 */
export function validateFunctionCall(
    contract: ContractWithStaticMembers,
    functionName: string,
    selector: string
): { valid: boolean; expectedSelector?: string; actualSelector: string } {
    const expectedSelector = getFunctionSelector(contract, functionName);

    return {
        valid: expectedSelector === selector,
        expectedSelector,
        actualSelector: selector
    };
}

/**
 * Get contract metadata including all available features
 */
export function getContractMetadata(contract: ContractWithStaticMembers) {
    return {
        name: contract.constructor.name,
        events: getContractEventSignatures(contract),
        functions: getContractFunctionSelectors(contract),
        errors: getContractErrorSelectors(contract),
        hasEventHelpers: Object.keys(contract).some(key => key.startsWith('has') && key.endsWith('Event')),
        hasSelectorHelpers: typeof contract.getFunctionSelector === 'function',
        hasErrorDecoders: Object.keys(contract).some(key => key.startsWith('decode') && key.endsWith('Error'))
    };
}

/**
 * Create a comprehensive contract analyzer
 */
export function createContractAnalyzer(contract: ContractWithStaticMembers) {
    return {
        // Event analysis
        hasEvent: (eventName: string, logs: any[]) => hasContractEvent(contract, eventName, logs),
        findEvents: (eventName: string, logs: any[]) => findContractEvents(contract, eventName, logs),
        getEventSignatures: () => getContractEventSignatures(contract),

        // Function analysis
        getFunctionSelector: (functionName: string) => getFunctionSelector(contract, functionName),
        getFunctionName: (selector: string) => getFunctionName(contract, selector),
        getFunctionSelectors: () => getContractFunctionSelectors(contract),
        validateCall: (functionName: string, selector: string) => validateFunctionCall(contract, functionName, selector),

        // Error analysis
        getErrorSelectors: () => getContractErrorSelectors(contract),
        decodeError: (errorData: string) => decodeContractErrorFromContract(contract, errorData),

        // Metadata
        getMetadata: () => getContractMetadata(contract)
    };
}
`;

        this.writeFile('src/utils/contract-helpers.ts', content);
    }

    /**
     * Generate event utilities
     */
    private generateEventUtilities(): void {
        const content = `/**
 * Generic event utilities for blockchain interaction
 * Auto-generated by ABIKIT
 */

import type { PublicClient, Address, Hash } from 'viem';

export interface EventRange {
    fromBlock?: bigint;
    toBlock?: bigint;
}

export interface EventLog {
    address: Address;
    topics: Hash[];
    data: Hash;
    blockNumber: bigint;
    transactionHash: Hash;
    logIndex: number;
}

export interface TypedEventLog<TEvent = any> extends EventLog {
    args: TEvent;
    eventName: string;
}

export interface BlockInfo {
    number: bigint;
    timestamp: bigint;
    hash: Hash;
    parentHash: Hash;
    gasLimit: bigint;
    gasUsed: bigint;
}

/**
 * Get typed event logs for a specific event
 */
export async function getTypedLogs<TEvent = any>(
    publicClient: PublicClient,
    address: Address,
    abi: any[],
    eventName: string,
    range: EventRange = {}
): Promise<TypedEventLog<TEvent>[]> {
    const logs = await publicClient.getLogs({
        address,
        event: {
            type: 'event',
            name: eventName,
            inputs: abi.find(item => item.type === 'event' && item.name === eventName)?.inputs || []
        },
        fromBlock: range.fromBlock ?? BigInt(0),
        toBlock: range.toBlock ?? 'latest'
    });

    return logs.map(log => ({
        ...log,
        args: log.args as TEvent,
        eventName
    }));
}

/**
 * Get block information for a block number
 */
export async function getBlockInfo(
    publicClient: PublicClient,
    blockNumber: bigint
): Promise<BlockInfo> {
    const block = await publicClient.getBlock({ blockNumber });

    return {
        number: block.number,
        timestamp: block.timestamp,
        hash: block.hash,
        parentHash: block.parentHash,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed
    };
}

/**
 * Get block timestamp for a block number
 */
export async function getBlockTimestamp(
    publicClient: PublicClient,
    blockNumber: bigint
): Promise<Date> {
    const block = await publicClient.getBlock({ blockNumber });
    return new Date(Number(block.timestamp) * 1000);
}

/**
 * Format block timestamp to ISO string
 */
export function formatBlockTimestamp(timestamp: bigint): string {
    return new Date(Number(timestamp) * 1000).toISOString();
}

/**
 * Get latest block number
 */
export async function getLatestBlockNumber(publicClient: PublicClient): Promise<bigint> {
    const block = await publicClient.getBlock({ blockTag: 'latest' });
    return block.number;
}

/**
 * Get block number for a specific timestamp (approximate)
 */
export async function getBlockNumberForTimestamp(
    publicClient: PublicClient,
    timestamp: bigint
): Promise<bigint> {
    // This is a simplified implementation
    // In practice, you might want to use a more sophisticated binary search
    const latestBlock = await publicClient.getBlock({ blockTag: 'latest' });
    
    if (timestamp >= latestBlock.timestamp) {
        return latestBlock.number;
    }

    // For now, return a rough estimate
    // In production, you'd want to implement proper binary search
    const timeDiff = Number(latestBlock.timestamp - timestamp);
    const blockDiff = BigInt(Math.floor(timeDiff / 12)); // Assuming 12 second blocks
    
    return latestBlock.number - blockDiff;
}

/**
 * Wait for a specific number of blocks
 */
export async function waitForBlocks(
    publicClient: PublicClient,
    blockCount: number
): Promise<void> {
    const startBlock = await getLatestBlockNumber(publicClient);
    const targetBlock = startBlock + BigInt(blockCount);

    while (true) {
        const currentBlock = await getLatestBlockNumber(publicClient);
        if (currentBlock >= targetBlock) {
            break;
        }
        // Wait 1 second before checking again
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
}
`;

        this.writeFile('src/utils/events.ts', content);
    }

    /**
     * Generate CREATE2 utilities
     */
    private generateCreate2Utilities(): void {
        const content = `/**
 * Generic CREATE2 address calculation utilities
 * Auto-generated by ABIKIT
 */

import { keccak256, encodePacked, getAddress } from 'viem';
import type { Address, Hex } from 'viem';

/**
 * Calculate CREATE2 address
 * Formula: keccak256(0xff + deployer + salt + keccak256(initCode))
 */
export function calculateCreate2Address(
    deployer: Address,
    salt: Hex,
    initCodeHash: Hex
): Address {
    const rawAddress = keccak256(
        encodePacked(
            ['bytes1', 'address', 'bytes32', 'bytes32'],
            ['0xff', deployer, salt, initCodeHash]
        )
    );

    // Mask to get the last 20 bytes
    return getAddress('0x' + rawAddress.slice(-40));
}

/**
 * Get init code hash from bytecode and constructor args
 */
export function getInitCodeHash(
    bytecode: Hex,
    constructorArgs?: Hex
): Hex {
    const fullCode = constructorArgs
        ? (bytecode + constructorArgs.slice(2)) as Hex
        : bytecode;

    return keccak256(fullCode);
}

/**
 * Generate a random salt
 */
export function generateRandomSalt(): Hex {
    const randomBytes = new Uint8Array(32);
    crypto.getRandomValues(randomBytes);
    return ('0x' + Array.from(randomBytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('')) as Hex;
}

/**
 * Generate salt from string parameters
 */
export function generateSaltFromString(input: string): Hex {
    return keccak256(new TextEncoder().encode(input));
}

/**
 * Check if an address was deployed using CREATE2
 */
export async function isCreate2Address(
    publicClient: any,
    address: Address,
    deployer: Address,
    salt: Hex,
    initCodeHash: Hex
): Promise<boolean> {
    const expectedAddress = calculateCreate2Address(deployer, salt, initCodeHash);
    return address.toLowerCase() === expectedAddress.toLowerCase();
}

`;

        this.writeFile('src/utils/create2.ts', content);
    }

    /**
     * Generate utils index file
     */
    private generateUtilsIndex(): void {
        const content = `/**
 * Utilities index
 * Auto-generated by ABIKIT
 */

export * from './blockchain';
export * from './contract-helpers';
export * from './events';
export * from './create2';
`;

        this.writeFile('src/utils/index.ts', content);
    }
}
