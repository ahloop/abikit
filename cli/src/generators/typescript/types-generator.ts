/**
 * TypeScript types generation logic
 */

import { ContractModel } from '../../types/model';
import { TypeScriptTargetOptions } from '../../types/config';
import { TypeScriptUtils } from './utils';

export class TypesGenerator {
    private outDir: string;

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    /**
     * Generate shared types file to avoid duplicates
     */
    async generateSharedTypesFile(contracts: ContractModel[]): Promise<void> {
        this.log('Generating shared types...');

        // Collect all unique structs across all contracts
        const allStructs = new Map<string, any>();

        for (const contract of contracts) {
            for (const struct of contract.structs) {
                if (!allStructs.has(struct.name)) {
                    allStructs.set(struct.name, struct);
                }
            }
        }

        // Add hardcoded types that are referenced but not defined in contracts
        const hardcodedTypes = this.getHardcodedTypes();
        for (const [name, struct] of hardcodedTypes) {
            if (!allStructs.has(name)) {
                allStructs.set(name, struct);
            }
        }

        if (allStructs.size === 0) {
            return; // No structs to generate
        }

        // Check if any structs use viem types
        const usesAddress = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'address')
        );
        const usesHash = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'bytes32')
        );
        const usesHex = Array.from(allStructs.values()).some(s =>
            s.fields.some((f: any) => f.type === 'bytes')
        );

        // Collect viem types needed by structs and shared helpers
        const viemTypesSet = new Set<string>();
        if (usesAddress) viemTypesSet.add('Address');
        if (usesHash) viemTypesSet.add('Hash');
        if (usesHex) viemTypesSet.add('Hex');

        // PreparedTransaction always uses Address and Hex for external signers
        viemTypesSet.add('Address');
        viemTypesSet.add('Hex');

        const viemTypes = Array.from(viemTypesSet);

        const viemImport = viemTypes.length > 0
            ? `import type { ${viemTypes.join(', ')} } from 'viem';\n`
            : '';

        const preparedTransactionType = `export interface PreparedTransaction {
  to: Address;
  data: Hex;
  value: bigint;
}
`;

        const structsContent = Array.from(allStructs.values()).map(struct => `export interface ${struct.name} {
${struct.fields.map((field: any) => `  ${field.name}: ${TypeScriptUtils.mapSolidityTypeToTS(field, contracts[0])};`).join('\n')}
}
`).join('\n');

        const content = `// Auto-generated shared types
// Generated by contract-sdk-gen

${viemImport}
${preparedTransactionType}
${structsContent}
`;

        this.writeFile('src/types/index.ts', content);
    }

    /**
     * Log helper
     */
    private log(message: string): void {
        console.log(`  ${message}`);
    }

    /**
     * Get hardcoded types that are referenced but not defined in contracts
     */
    private getHardcodedTypes(): Map<string, any> {
        const types = new Map<string, any>();

        // Add the missing types that are referenced in Bid interface
        types.set('Requirements', {
            name: 'Requirements',
            fields: [
                { name: 'requireVerified', type: 'bool' },
                { name: 'allowedAttestationRoots', type: 'bytes32' },
                { name: 'allowedAgentsRoot', type: 'bytes32' },
                { name: 'minTrustScore', type: 'uint256' }
            ]
        });

        types.set('Payment', {
            name: 'Payment',
            fields: [
                { name: 'token', type: 'address' },
                { name: 'amount', type: 'uint256' },
                { name: 'authorizationSig', type: 'bytes' }
            ]
        });

        types.set('Timing', {
            name: 'Timing',
            fields: [
                { name: 'startTime', type: 'uint256' },
                { name: 'endTime', type: 'uint256' },
                { name: 'nonce', type: 'bytes32' },
                { name: 'signature', type: 'bytes' }
            ]
        });

        types.set('Status', {
            name: 'Status',
            fields: [
                { name: 'requestHash', type: 'bytes32' },
                { name: 'responseHash', type: 'bytes32' },
                { name: 'completedBy', type: 'bytes32' },
                { name: 'state', type: 'uint8' },
                { name: 'refundPercent', type: 'uint8' }
            ]
        });

        return types;
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
