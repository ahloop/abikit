/**
 * TypeScript config generation logic
 */

import { ContractGraph } from '../../types/model';
import { GeneratorContext } from '../base';
import { TypeScriptTargetOptions } from '../../types/config';

export class ConfigGenerator {
    private outDir: string;
    private contractMappings: Map<string, string> = new Map();

    constructor(outDir: string, _options: TypeScriptTargetOptions) {
        this.outDir = outDir;
    }

    getContractMappings(): Map<string, string> {
        return this.contractMappings;
    }

    /**
     * Generate config package
     */
    async generateConfig(graph: ContractGraph, context: GeneratorContext): Promise<void> {
        await this.generateAddresses(graph, context);
        await this.generateRuntimeConfig(graph, context);
        await this.generateConfigIndex();
    }

    /**
     * Generate addresses.ts
     */
    private async generateAddresses(graph: ContractGraph, context: GeneratorContext): Promise<void> {
        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        // Build contract mappings: alias -> contract class name
        this.contractMappings.clear();

        // Collect all contracts across networks
        const allContractNames = new Set<string>();
        networkNames.forEach(network => {
            const networkConfig = networks[network];
            const contracts = (networkConfig as any)?.contracts || {};
            Object.entries(contracts).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    allContractNames.add(key);
                } else {
                    allContractNames.add(key);
                    const contractName = (value as any).name || key;
                    this.contractMappings.set(key, contractName);
                }
            });
        });

        // Filter out interfaces and zero addresses
        const contractNames = Array.from(allContractNames)
            .filter(name => {
                const contractClass = this.contractMappings.get(name) || name;
                return !graph.contracts.get(contractClass)?.isInterface;
            })
            .sort() as string[];

        const content = `// Auto-generated contract addresses by network
// Generated by contract-sdk-gen

export interface NetworkAddresses {
${contractNames.map(name => `  ${name}: string;`).join('\n')}
}

export interface NetworkContracts {
${networkNames.map(network => `  ${this.quoteIfNeeded(network)}: NetworkAddresses;`).join('\n')}
}

export const NETWORK_CONTRACTS: NetworkContracts = {
${networkNames.map(network => {
            const networkConfig = networks[network];
            const contracts = (networkConfig as any)?.contracts || {};
            return `  ${this.quoteIfNeeded(network)}: {
${contractNames.map(name => {
                const contractValue = contracts[name];
                let address: string;
                if (typeof contractValue === 'string') {
                    address = contractValue;
                } else {
                    address = contractValue?.address || '0x0000000000000000000000000000000000000000';
                }
                return `    ${name}: "${address}",`;
            }).join('\n')}
  },`;
        }).join('\n')}
};

export function getContractAddress(network: string, contract: string): string {
  const networkContracts = NETWORK_CONTRACTS[network as keyof NetworkContracts];
  if (!networkContracts) {
    throw new Error(\`Network \${network} not found\`);
  }
  
  const address = networkContracts[contract as keyof NetworkAddresses];
  if (!address) {
    throw new Error(\`Contract \${contract} not found for network \${network}\`);
  }
  
  return address;
}

export function getAvailableNetworks(): string[] {
  return Object.keys(NETWORK_CONTRACTS);
}

export function getNetworkAddresses(network: string): NetworkAddresses {
  const networkContracts = NETWORK_CONTRACTS[network as keyof NetworkContracts];
  if (!networkContracts) {
    throw new Error(\`Network \${network} not found\`);
  }
  return networkContracts;
}
`;

        this.writeFile('src/config/addresses.ts', content);
    }

    /**
     * Generate runtime-config.ts
     */
    private async generateRuntimeConfig(_graph: ContractGraph, context: GeneratorContext): Promise<void> {
        const networks = context.networks || {};
        const networkNames = Object.keys(networks);

        const content = `// Auto-generated runtime configuration
// Generated by contract-sdk-gen

import type { Chain } from 'viem';
import { NETWORK_CONTRACTS } from './addresses';

export interface RuntimeConfig {
  chain: Chain;
  networkName: string;
  contracts: typeof NETWORK_CONTRACTS[keyof typeof NETWORK_CONTRACTS];
}

export const SUPPORTED_NETWORKS = [
${networkNames.map(network => `  '${network}',`).join('\n')}
] as const;

export type SupportedNetwork = typeof SUPPORTED_NETWORKS[number];

export function createRuntimeConfig(networkName: SupportedNetwork, chain: Chain): RuntimeConfig {
  return {
    chain,
    networkName,
    contracts: NETWORK_CONTRACTS[networkName],
  };
}
`;

        this.writeFile('src/config/runtime-config.ts', content);
    }

    /**
     * Generate config index
     */
    private async generateConfigIndex(): Promise<void> {
        const content = `// Auto-generated config barrel index
// Generated by contract-sdk-gen

export * from './addresses';
export * from './runtime-config';
`;

        this.writeFile('src/config/index.ts', content);
    }


    private quoteIfNeeded(str: string): string {
        // Quote if contains hyphens or other special characters
        return /[^a-zA-Z0-9_]/.test(str) ? `"${str}"` : str;
    }

    /**
     * Write file helper
     */
    private writeFile(relativePath: string, content: string): void {
        const fs = require('fs');
        const path = require('path');
        const fullPath = path.join(this.outDir, relativePath);
        const dir = path.dirname(fullPath);

        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
    }
}
